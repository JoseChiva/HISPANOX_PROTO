#<AdxTL>@(#)0.0.0.0 $Revision$
# 06.339.932 - JC.02052022.Errores cálculo cobertura artículos
###############################################################################

#If !clalev([F:ZSID]) Then : Local File SINVOICED  [F:ZSID] : Endif
#Filter [F:ZSID] Where NUM = "PHISP2105PRF00000001"
#Read [F:ZSID] First
#Infbox num$((date$ - [F:ZSID]INVDAT))
#Filter [F:ZSID]
#Close Local File [ZSID]
#Local Char S_UNIWEI(50) : S_UNIWEI = "G"
#Infbox num$(func CONVERTIR_CANTIDAD(S_UNIWEI,"KG", 216742))
#Infbox num$(func CANTIDAD_CAJA('2128'))
#Local Char LSTRING(250) : LSTRING = "Buenos d<>as, ruego cuando"
Infbox func ZAULIB01.CALC_EANCOD()
End

###############################################################################
#         ELIMINAR CARACTERES QUE ACOMPAÑAN A UN TEXTO EN FORMATO RTF         #
#             LA LLAMADA SERÍA COMO EN EL EJEMPLO ABAJO MOSTRADO              #
#           Y LAS FUNCIONES SON LAS 3 QUE APARECEN A CONTINUACIÓN             #
#                   F_RTF2TEXT, S_RTF2TEXT, F_GETNEXTCHR                      #
###############################################################################
#$MYTEST
#  If !clalev ([F:SOH]) : Local File SORDER [F:SOH] : Endif
#  If !clalev ([F:TXC]) : Local File TEXCLOB [F:TXC] : Endif
#
#  Filter [F:SOH]
#  Filter [F:TXC]
#  For [F:SOH] Where SOHNUM = "000000001"
#    For [F:TXC] Where CODE = [F:SOH]SOHTEX1
#      Local Char MYTEXT(250)
#        MYTEXT = func F_RTF2TEXT([F:TXC]TEXTE)
#        Infbox "MYTEXT= "+ MYTEXT
#    Next
#  Next
#Return
###############################################################################

###############################################################################
Funprog F_RTF2TEXT(CLOB)

Variable Clbfile CLOB

Local Integer LENTXMT : LENTXMT = 250
Local Integer NRIGHE : NRIGHE = 4 # 4 = 250x4 char
Local Char    XOUT(LENTXMT)(NRIGHE)

  Call S_RTF2TEXT(LENTXMT,CLOB,XOUT,NRIGHE)
  #Concatenate the row with plain text, by removing the empty space
  Local Char XRET(250) : Raz XRET
  For XI = 0 To NRIGHE
    XRET += vireblc(XOUT(XI),2)
  Next

End XRET


###############################################################################
Subprog S_RTF2TEXT(PLENRIGAOUT,CLOB,PTXTOUT,PNRIGEOUT)
Value Integer PLENRIGAOUT
Variable Clbfile CLOB
Variable Char PTXTOUT
Variable Integer PNRIGEOUT

Local Integer XRIGHE
Local Integer XNOL
Local Integer XNCH
Local Char XCH(1)
Local Char XCHPREV(1)
Local Integer XSTRTAG1 : XSTRTAG1 = 0
Local Integer XSTRTAG2 : XSTRTAG2 = 0
Local Integer LENGHT : LENGHT = len(CLOB)
Local Integer CLOTAI : CLOTAI = int(LENGHT/GCLOLNG)+1
Local Char PRTFIN (GCLOLNG)(CLOTAI)

  Setlob PRTFIN With CLOB
  XRIGHE = dim(PRTFIN,1)

Local Char XOUT(250)(XRIGHE)
Local Integer XOUTRLEN(XRIGHE)
Local Char RIGA(250)
Local Integer XESCAPE

 #Toglie i tag RTF
  For XNOL = 0 To XRIGHE - 1
    Raz RIGA
    RIGA = PRTFIN(XNOL)
    XOUTRLEN(XNOL) = 0
    For XNCH = 1 To len(RIGA)
      XCHPREV = XCH
      XCH = mid$(RIGA,XNCH,1)
      If XCH = "\" Then
        XESCAPE = -1
        If func F_GETNEXTCHR(PRTFIN,1,XNCH,XNOL,XRIGHE)= "}" Then
          XCHPREV = XCH
          XNCH = XNCH + 1
          XCH = "}"
          XESCAPE = 1
        Endif
        If func F_GETNEXTCHR(PRTFIN,1,XNCH,XNOL,XRIGHE)= "{" Then
          XCHPREV = XCH
          XNCH = XNCH + 1
          XCH = "{"
          XESCAPE = 1
        Endif
        If func F_GETNEXTCHR(PRTFIN,4,XNCH,XNOL,XRIGHE)= "pard" Then
          XNCH = XNCH + 4
          XCH = " "
          XESCAPE = 1
        Endif
        If func F_GETNEXTCHR(PRTFIN,3,XNCH,XNOL,XRIGHE)= "par" Then
          XNCH = XNCH + 3
          XCH = " "
          XESCAPE = 1
        Endif
        If func F_GETNEXTCHR(PRTFIN,3,XNCH,XNOL,XRIGHE)= "'e0" Then
          XNCH = XNCH + 3
          XCH = "a"
          XESCAPE = 1
        Endif
        If func F_GETNEXTCHR(PRTFIN,3,XNCH,XNOL,XRIGHE)= "'e9" Then
          XNCH = XNCH + 3
          XCH = "e"
          XESCAPE = 1
        Endif
        If func F_GETNEXTCHR(PRTFIN,3,XNCH,XNOL,XRIGHE)= "'e8" Then
          XNCH = XNCH + 3
          XCH = "e"
          XESCAPE = 1
        Endif
        If func F_GETNEXTCHR(PRTFIN,3,XNCH,XNOL,XRIGHE)= "'b0" Then
          XNCH = XNCH + 3
          XCH = "°"
          XESCAPE = 1
        Endif
        If func F_GETNEXTCHR(PRTFIN,3,XNCH,XNOL,XRIGHE)= "'ec" Then
          XNCH = XNCH + 3
          XCH = "i"
          XESCAPE = 1
        Endif
        If func F_GETNEXTCHR(PRTFIN,3,XNCH,XNOL,XRIGHE)= "'f2" Then
          XNCH = XNCH + 3
          XCH = "o"
          XESCAPE = 1
        Endif
        If func F_GETNEXTCHR(PRTFIN,3,XNCH,XNOL,XRIGHE)= "'f9" Then
          XNCH = XNCH + 3
          XCH = "u"
          XESCAPE = 1
        Endif
        If func F_GETNEXTCHR(PRTFIN,2,XNCH,XNOL,XRIGHE)= "fs" Then #Font size
          XNCH = XNCH + 2
          XCH = ""
          XESCAPE = -1
        Endif
        If XESCAPE = -1 Then
          XSTRTAG1 = 1
          XNCH = XNCH + 1
        Endif
      Endif
      If XCH = "{" and XCHPREV <> "\" Then XSTRTAG2 = XSTRTAG2 + 1 : Endif
      If XSTRTAG1 = 0 and XSTRTAG2 <= 1 Then
        XOUT(XNOL) += XCH
        XOUTRLEN(XNOL) += 1
      Endif
      If XCH = " " or find(func F_GETNEXTCHR(PRTFIN,2,XNCH-1,XNOL,XRIGHE) ,'\}','\{','\\') > 0 Then XSTRTAG1 = 0 : Endif
      If XCH = "}" and XCHPREV <> "\" Then XSTRTAG2 = XSTRTAG2 - 1 : Endif
    Next
  Next

Local Integer XNOL2
Local Integer XCONTA2

  XNOL2 = 0
  XCONTA2 = PLENRIGAOUT
  For XNOL = 0 To XRIGHE - 1
    Raz RIGA
    RIGA = XOUT(XNOL)
    If XNOL = XRIGHE : RIGA = vireblc(RIGA,1) : Endif
    If len(RIGA) > 0 Then
      For XNCH = 1 To len(RIGA)
        XCH = mid$(RIGA,XNCH,1)
        If XCH = chr$(13) Then
          XCH = " "
          If func F_GETNEXTCHR(XOUT,1,XNCH,XNOL,XRIGHE)= chr$(10) Then
            XNCH = XNCH + 1
          Endif
        Endif
        If XCH = chr$(10) Then
          XCH = " "
          If func F_GETNEXTCHR(XOUT,1,XNCH,XNOL,XRIGHE)= chr$(13) Then
            XNCH = XNCH + 1
          Endif
        Endif
        If XNCH = 1 and XNOL = 0 and XCH = "{" Then XCH = "" : Endif
        PNRIGEOUT = XNOL2 + 1
        PTXTOUT(XNOL2) += XCH
        XCONTA2 = XCONTA2 - 1
        If XCONTA2 = 0 Then
          XNOL2 = XNOL2 + 1
          XCONTA2 = PLENRIGAOUT
        Endif
      Next
    Endif
  Next

  #tolgo la graffa finale
  RIGA = vireblc(PTXTOUT(XNOL2),1)
  If mid$(RIGA,len(RIGA),1) = "}" Then
    PTXTOUT(XNOL2) = mid$(RIGA,1,len(RIGA)-1)
  Endif

End

###############################################################################
Funprog F_GETNEXTCHR(PARRIN,NCHNEXT,NCURPOS,NCURNOL,NTOTRIGHE)
Value Char PARRIN
Value Integer NCHNEXT
Value Integer NCURPOS
Value Integer NCURNOL
Value Integer NTOTRIGHE

Local Char XRET(NCHNEXT) : XRET = ""
Local Integer XNCH
Local Char RIGA(250)
Local Integer XCONTA

  For XNOL = NCURNOL To NTOTRIGHE - 1
    RIGA = PARRIN(NCURNOL)
    For XNCH = NCURPOS + 1 To len(RIGA) - 1
      XRET += mid$(RIGA,XNCH,1)
      XCONTA += 1
      If XCONTA = NCHNEXT Then
        Break
      Endif
    Next
    If XCONTA = NCHNEXT Then
      Break
    Endif
    NCURPOS = 0
  Next

End XRET

##############################################################
#**
#* devuelve el valor redondeado al alza con un número determinado de decimales
#*
#* @param PS_NUM  > número
#* @param PS_NDEC > número de decimales
#*!
Funprog REDONDEA_ALZA(PS_NUM,PS_NDEC)
Value Decimal PS_NUM,PS_NDEC

Local Char    LSTR(250)
Local Decimal LPOT : LPOT = 1
Local Integer LCON

  LSTR = format$("N:5."+num$(PS_NDEC),PS_NUM)
  LSTR = ctrans(LSTR,",",".")

  For LCON=1 To PS_NDEC
    LPOT = LPOT * 0.1
  Next

End (val(LSTR) + LPOT)

##############################################################
#**
#* convierte una cantidad de la unidad de origen a la de destino
#*
#* @param PS_UOM_ORI  > unidad de origen
#* @param PS_UOM_DES  > unidad de destino
#* @param PS_QTY      > cantidad a convertir
#*!
Funprog CONVERTIR_CANTIDAD(PS_UOM_ORI,PS_UOM_DES,PF_QTY)
Value Char PS_UOM_ORI
Value Char PS_UOM_DES
Value Decimal PF_QTY

Local Decimal F_QTY_DES

Local File TABCOEFF [F:ZTCO]

If PS_UOM_ORI = "" or PS_UOM_DES = "" or PS_UOM_ORI = PS_UOM_DES Then
  F_QTY_DES = PF_QTY
Else
  Read [F:ZTCO]TCO0 = PS_UOM_ORI;PS_UOM_DES
  If fstat = 0 Then
    F_QTY_DES = PF_QTY * [F:ZTCO]COEUOM
  Endif
Endif

Close Local File [F:ZTCO]

End F_QTY_DES

##############################################################
#**
#* devuelve el valor correspondiente al coste oferta
#*
#* @param PITM  > artículo
#* @param PFCY  > planta
#*!
Funprog GET_COSTEOFERTA(PITM,PFCY)
# parámetros de entrada
Value Char PITM,PFCY

# declaración de variables
Local Decimal LRET

  # función de cálculo
  If !clalev([F:ZITF]) Then : Local File ITMFACILIT [F:ZITF] : Endif
  If !clalev([F:ZITV]) Then : Local File ITMMVT     [F:ZITV] : Endif
  Read [F:ZITF]ITF0 = PITM;PFCY
  If !fstat Then
    If [F:ZITF]ZCMOFIX <> 0 Then
      LRET = [F:ZITF]ZCMOFIX
    Else
      If [F:ZITF]ZCMO > [F:ZITF]ZCMOMIN Then
        LRET = [F:ZITF]ZCMO
      Else
        LRET = [F:ZITF]ZCMOMIN
      Endif
    Endif
  Endif
  If LRET = 0 Then
    Read [F:ZITV]ITV0 = PITM;PFCY
    If !fstat Then
      LRET = [F:ZITV]AVC
    Endif
  Endif
  Close Local File [ZITF],[ZITV]

End LRET

##############################################################
#**
#* devuelve el stock físico de un artículo/planta
#*
#* @param PITM  > artículo
#* @param PFCY  > planta
#*!
Funprog GET_PHYSTO(PITM,PFCY)
# parámetros de entrada
Value Char PITM,PFCY

# declaración de variables
Local Decimal LRET

  If !clalev([F:ZITV]) Then : Local File ITMMVT [F:ZITV] : Endif
  Read [F:ZITV]ITV0 = PITM;PFCY
  If !fstat Then
    LRET = [F:ZITV]PHYSTO
  Endif
  Close Local File [ZITV]

End LRET

##############################################################
#**
#* devuelve el stock disponible de un artículo/planta para un documento (presupuesto,pedido...)
#*
#* @param PS_VCRNUM > documento
#* @param PS_ITMREF > artículo
#* @param PS_FCY    > planta
#* @param PI_LIN    > línea
#* @param PI_ERROR  > flag error
#*!
Funprog STOCK_DISPONIBLE(PS_VCRNUM,PS_ITMREF,PS_FCY,PI_LIN, PI_ERROR)
# parámetros de entrada
Value Char PS_VCRNUM
Value Char PS_ITMREF
Value Char PS_FCY
Value Integer PI_LIN

# parámetro de salida
Variable Integer PI_ERROR

# declaración de variables
Local Char    S_LOT(GLONLOT)  : [L]S_LOT = "*"
Local Char    S_LOC(GLONLOC)  : [L]S_LOC = "*"
Local Decimal F_STODISPO
Local Char    S_CATEGORIA(GLONITG)
Local Integer I_CALIDAD

  #Tablas necesarias para la función
  Local File ITMMVT    [ITV]
  Local File SORDERQ   [SOQ]
  Local File ITMMASTER [ITM]
  Local File ITMCATEG  [ITG]


  Read [F:ITV]ITV0 = PS_ITMREF;PS_FCY
  If fstat <> 0 Then
    PI_ERROR = 1
  Endif

  If !PI_ERROR Then
    #Abrimos la tabla Pedidos de venta - Cantidades
    If PS_VCRNUM <> "" Then
      Read [F:SOQ]SOQ0 = PS_VCRNUM;PI_LIN;PI_LIN
      If fstat = 0 Then
        If [F:SOQ]LOT <> "" Then
          [L]S_LOT = [F:SOQ]LOT
        Endif
        If [F:SOQ]LOC <> "" Then
          [L]S_LOC = [F:SOQ]LOC
        Endif
      Endif
    Endif

    If !PI_ERROR Then
      Read [ITM]ITM0 = PS_ITMREF
      If fstat = 0 Then
        [L]S_CATEGORIA = [F:ITM]TCLCOD
        Read [ITG]ITG0 = PS_FCY;[L]S_CATEGORIA
        If fstat <> 0 Then
          Read [ITG]ITG0= "";[L]S_CATEGORIA
          If fstat <> 0 Then
            PI_ERROR = fstat
          Endif
        Endif
        If !PI_ERROR Then
          If [F:ITG]GLOAAAFLG = 2 Then
            [L]I_CALIDAD += 1
          Endif
          If [F:ITG]GLOQQQFLG = 2 Then
            [L]I_CALIDAD += 2
          Endif
          If [F:ITG]GLORRRFLG = 2 Then
            [L]I_CALIDAD += 4
          Endif
            Call STODISPO("",PS_FCY,PS_ITMREF,[L]S_LOT,[L]S_LOC,0,[L]I_CALIDAD,"","","","",[L]F_STODISPO) From STKLIB
        Endif
      Else
        PI_ERROR = fstat
      Endif
    Endif
  Endif

  Close Local File [ITV],[SOQ],[ITM],[ITG]

End [L]F_STODISPO

##############################################################
# 06.339.932
#**
#* devuelve el stock disponible buscando en la tabla ITMMVT
#*
#* @param PS_ITMREF > artículo
#* @param PS_FCY    > planta
#*!
Funprog STOCK_DISPONIBLE_ITV(PS_ITMREF,PS_FCY)
# parámetros de entrada
Value Char PS_ITMREF,PS_FCY

Local Integer LRES
Local Decimal LSTOKIT

  If !clalev([F:ZITV]) Then : Local File ITMMVT [F:ZITV] : Endif
  If !clalev([F:ZBOD]) Then : Local File BOMD   [F:ZBOD] : Endif

  Read [F:ZITV]ITV0 = PS_ITMREF;PS_FCY
  If !fstat Then
    LRES = [F:ZITV]PHYSTO-[F:ZITV]GLOALL-[F:ZITV]PHYALL-[F:ZITV]GLOSHT
  Endif

  Filter [F:ZBOD] Where CPNITMREF = PS_ITMREF
  For [F:ZBOD]
    Read [F:ZITV]ITV0 = [F:ZBOD]ITMREF;PS_FCY
    If !fstat Then
      LSTOKIT = [F:ZITV]PHYSTO-[F:ZITV]GLOALL-[F:ZITV]PHYALL-[F:ZITV]GLOSHT
      If LSTOKIT < 0 Then
        LRES += LSTOKIT
      Endif
    Endif
  Next
  Filter [F:ZBOD]

  Close Local File [ZITV],[ZBOD]

End LRES

##############################################################
#**
#* devuelve el múltiple de caja para un artículo
#*
#* @param PS_ITMREF > artículo
#*!
Funprog CANTIDAD_CAJA(PS_ITMREF)
# parámetros de entrada
Value Char PS_ITMREF

  Local File ITMFACILIT [ITF]
  Local File ITMMASTER  [ITM]

  Read [F:ITF]ITF0 = PS_ITMREF;"PHISP"
  If fstat = 0 and [F:ITF]STOMGTCOD <> 1 Then
    Read [F:ITM]ITM0 = PS_ITMREF
    If fstat = 0 Then
      For I = 0 To dim([F:ITM]PCU)
        If [F:ITM]PCU(I) = "CAJ" Then
          End  [F:ITM]PCUSTUCOE(I)
        Endif
      Next
    Endif
  Endif

  Close Local File [ITM],[ITF]

End 0

##############################################################
#**
#* devuelve la referencia de Artículo-cliente
#*
#* @param PS_ITMREF > artículo
#* @param PS_BPCORD > cliente
#*!
Funprog GET_REF_ITU(PS_ITMREF, PS_BPCORD)
# parámetros de entrada
Value Char PS_ITMREF
Value Char PS_BPCORD

  Local File ITMBPC [ITU]
  Read [ITU]ITU0 = PS_ITMREF;PS_BPCORD
  If fstat = 0 Then
    End [F:ITU]ITMREFBPC
  Endif
  Close Local File [ITU]

End ""

##############################################################
#**
#* devuelve el coste medio oferta (CMO)
#*
#* @param PS_ITMREF > artículo
#* @param PS_FCY    > planta
#*!
Funprog GET_CMO(PS_ITMREF,PS_FCY)
# parámetros de entrada
Value Char PS_ITMREF,PS_FCY

  If !clalev([F:ZITF]) Then : Local File ITMFACILIT [F:ZITF] : Endif
  Read [F:ZITF]ITF0 = PS_ITMREF;PS_FCY
  If !fstat Then
    End [F:ZITF]ZCMO
  Endif
  Close Local File [ZITF]

End 0

##############################################################
#**
#* devuelve la cantidad en expedición pendiente recibir
#*
#* @param PS_ITMREF > artículo
#* @param PS_FCY    > planta
#*!
Funprog GET_CEPR(PS_ITMREF,PS_FCY)
# parámetros de entrada
Value Char PS_ITMREF,PS_FCY

# declaración de variables
Local Decimal LRET

  If !clalev([F:ZCTD]) Then : Local File CONTAINERD [F:ZCTD] : Endif
  If !clalev([F:ZSHD]) Then : Local File SHIPMENTD  [F:ZSHD] : Endif

  # cantidad pendiente en Contenedor de carga que todavía no está en expediciones
  Filter [F:ZCTD] Where ITMREF = PS_ITMREF and SHIPNUM = ""
  For [F:ZCTD]
    LRET += [F:ZCTD]QTYUOM
  Next
  Filter [F:ZCTD]

  # cantidad pendiente en Expediciones no Rececepcionada (tanto si está prerecepcionada como si no lo está)
  Filter [F:ZSHD] Where ITMREF = PS_ITMREF and POHFCY = PS_FCY and CLEFLG = 1
  For [F:ZSHD]
    LRET += [F:ZSHD]SHIQTY
  Next
  Filter [F:ZSHD]

  Close Local File [ZCTD],[ZSHD]

End LRET

##############################################################
#**
#* devuelve el stock disponible
#*
#* @param PS_ITMREF > artículo
#* @param PS_FCY    > planta
#*!
Funprog GET_STK(PS_ITMREF,PS_FCY)
# parámetros de entrada
Value Char PS_ITMREF,PS_FCY

# declaración de variables
Local Decimal LRET

  If !clalev([F:ZITV]) Then : Local File ITMMVT     [F:ZITV] : Endif
  If !clalev([F:ZITG]) Then : Local File ITMCATEG   [F:ZITG] : Endif
  If !clalev([F:ZITM]) Then : Local File ITMMASTER  [F:ZITM] : Endif

  Read [F:ZITM]ITM0 = PS_ITMREF
  Read [F:ZITG]ITG1 = [F:ZITM]TCLCOD;""
  Read [F:ZITV]ITV0 = [F:ZITM]ITMREF;PS_FCY
  Call STODISTOT("",0,0,"",LRET) From STKLIB

  Close Local File [ZITV],[ZITG],[ZITM]

End LRET

##############################################################
#**
#* devuelve las ventas en los 12 últimos meses
#*
#* @param PS_ITMREF > artículo
#* @param PS_FCY    > planta
#*!
Funprog GET_V12(PS_ITMREF,PS_FCY)
# parámetros de entrada
Value Char PS_ITMREF,PS_FCY

# declaración de variables
Local Decimal LRET
#Local Date    DAT1 : DAT1 = date$-365
#Local Date    DAT2 : DAT2 = date$
Raz LRET

#  If !clalev([F:ZSAT]) Then : Local File STAT [F:ZSAT] : Endif
#  Filter [ZSAT] Where COD = "ZS12M" and FCY = PS_FCY and DAT >= DAT1 and DAT <= DAT2 and CRI1 = PS_ITMREF
#  For [ZSAT]
#    LRET += [F:ZSAT]AMT(0)
#  Next
#  Close Local File [ZSAT]

   If !clalev([F:ZVSAT]) Then : Local File ZNETZS12M [F:ZVSAT] : Endif

   Read [F:ZVSAT]ZVS12M0=PS_FCY;PS_ITMREF
   If !fstat
# 06.339.932.ini
#    LRET=[F:ZVSAT]AMT
    LRET=max([F:ZVSAT]AMT,0)
# 06.339.932.ini
   Endif
   Close Local File [ZVSAT]

End LRET

##############################################################
#**
#* devuelve la cobertura de un artículo
#*
#* @param PS_ITMREF > artículo
#* @param PS_FCY    > planta
#*!
Funprog GET_COBERTURA(PS_ITMREF,PS_FCY)
# parámetros de entrada
Value Char PS_ITMREF,PS_FCY

# declaración de variables
Local Decimal LV12,LSTOCKD,LCEPR,LRET
Local Integer LERROR

  LRET = 999

  # obtener V12
  LV12    = func GET_V12(PS_ITMREF,PS_FCY)
  # obtener STOCK
  LSTOCKD = func STOCK_DISPONIBLE("",PS_ITMREF,PS_FCY,0,LERROR)
# 06.339.932.ini
  If LSTOCKD <= 0 Then : End 0 : Endif
# 06.339.932.fin
  # obtener CEPR
  #LCEPR   = func GET_CEPR(PS_ITMREF,PS_FCY)                            # JC.230920.NEW
  # función de cálculo
  If LV12 <> 0 Then
#    End ar2((12*(LSTOCKD+LCEPR)) / LV12)                               # JC.230920.NEW
    If ar2((12*(LSTOCKD)) / LV12) <> 0 Then                             # JC.230920.NEW
      LRET = ar2((12*(LSTOCKD)) / LV12)                                    # JC.230920.NEW
    Endif
  Endif

End LRET

##############################################################
# 06.339.932
#**
#* devuelve la cobertura de un artículo en función de la tabla ITMMVT
#*
#* @param PS_ITMREF > artículo
#* @param PS_FCY    > planta
#*!
Funprog GET_COBERTURA_ITV(PS_ITMREF,PS_FCY)
# parámetros de entrada
Value Char PS_ITMREF,PS_FCY

# declaración de variables
Local Decimal LSTKREALITMREF,LSTKREALPADRE
Local Decimal LSTKSOHITMREF,LSTKSOHPADRE
Local Decimal LV12ITMREF,LV12PADRE
Local Decimal LRET

  LRET = 999

  # ****ARTÍCULO QUE SE PASA COMO PARÁMETRO****
  If !clalev([F:ITN0]) Then : Local File ZITMTRANET [F:ITN0]  : Endif
  If !clalev([F:ITV0]) Then : Local File ITMMVT     [F:ITV0]  : Endif
  # stock real
  Filter [F:ITN0] Where ITMREF = PS_ITMREF
  Read [F:ITN0] First
  LSTKREALITMREF = [F:ITN0]STOCK_REAL
  Filter [F:ITN0]
  # stock en pedidos de cliente
  Read [F:ITV0]ITV0 = PS_ITMREF;PS_FCY
  LSTKSOHITMREF = [F:ITV0]SALSTO
  # salidas 12 meses
  LV12ITMREF = max(func GET_V12(PS_ITMREF,PS_FCY),0)

  # ****COMPUESTOS CUANDO FORMA PARTE DE UN KIT****
  If !clalev([F:BOD1]) Then : Local File BOMD       [F:BOD1] : Endif
  If !clalev([F:ITN1]) Then : Local File ZITMTRANET [F:ITN1]  : Endif
  If !clalev([F:ITV1]) Then : Local File ITMMVT     [F:ITV1]  : Endif

  Filter [F:BOD1] Where CPNITMREF = PS_ITMREF
  For [F:BOD1]
    # stock real
    Filter [F:ITN1] Where ITMREF = [F:BOD1]ITMREF
    Read [F:ITN1] First
    LSTKREALPADRE += [F:ITN1]STOCK_REAL * [F:BOD1]BOMQTY
    Filter [F:ITN1]
    # stock en pedido de cliente
    Read [F:ITV1]ITV0 = [F:BOD1]ITMREF;PS_FCY
    LSTKSOHPADRE += [F:ITV1]SALSTO * [F:BOD1]BOMQTY
    # salidas 12 meses
    LV12PADRE     += func GET_V12([F:BOD1]ITMREF,PS_FCY) * [F:BOD1]BOMQTY
  Next
  LV12PADRE = max(LV12PADRE,0)

  # ****CÁLCULO DE LA COBERTURA****
  If (LSTKREALITMREF + LSTKREALPADRE - LSTKSOHITMREF - LSTKSOHPADRE) <= 0 Then
    LRET = 0
  Else
    # fórmula indicada por Sergi
    # cobertura = (Stock + SUMA(stock_kits/sub*qty_comp) – pend_pedidos_clientes – SUMA(pend_pedidos_clientes_kits/sub*qty_comp) ) / (ventas_12m + SUMA(ventas_12m_kits/sub*qty_comp)) * 12
    If LV12ITMREF + LV12PADRE > 0 Then
      LRET = ar2(((LSTKREALITMREF + LSTKREALPADRE - LSTKSOHITMREF - LSTKSOHPADRE) / (LV12ITMREF + LV12PADRE)) * 12)
    Elsif LV12ITMREF + LV12PADRE = 0 Then
# 06.339.932.ini
#      LRET = 0
      LRET = 999
# 06.339.932.fin
    Else
      LRET = 999
    Endif
  Endif


  Close Local File [ITN0],[ITN1],[BOD1],[ITV1]

End LRET

##############################################################
#**
#* devuelve la cobertura de un artículo en función de la tabla ITMMVT
#*
#* @param PS_ITMREF > artículo
#* @param PS_FCY    > planta
#*!
Funprog GET_COBERTURA_ITV_VISTAS(PS_ITMREF,PS_FCY)
# parámetros de entrada
Value Char PS_ITMREF,PS_FCY

# declaración de variables
Local Decimal LSTKREALITMREF,LSTKREALPADRE
Local Decimal LSTKSOHITMREF,LSTKSOHPADRE
Local Decimal LV12ITMREF,LV12PADRE
Local Decimal LRET

  LRET = 999

  # ****ARTÍCULO QUE SE PASA COMO PARÁMETRO****
  If !clalev([F:ITV0]) Then : Local File ITMMVT     [F:ITV0]  : Endif
  Read [F:ITV0]ITV0 = PS_ITMREF;PS_FCY
  # stock real
  LSTKREALITMREF = [F:ITV0]PHYSTO + [F:ITV0]CTLSTO + [F:ITV0]REJSTO
  # stock en pedidos de cliente
  LSTKSOHITMREF = [F:ITV0]SALSTO
  # salidas 12 meses
  LV12ITMREF = max(func GET_V12(PS_ITMREF,PS_FCY),0)

  # ****COMPUESTOS CUANDO FORMA PARTE DE UN KIT****
  If !clalev([F:ITK0]) Then : Local File ZITMINTRAKIT [F:ITK0] : Endif
  Filter [F:ITK0] Where CPNITMREF = PS_ITMREF
  Read [F:ITK0] First
  If !fstat Then
    LSTKREALPADRE = [F:ITK0]SUM_STK_REAL
    LSTKSOHPADRE  = [F:ITK0]SUM_PED_CLI
    LV12PADRE     = [F:ITK0]SUM_SALIDA12
    LV12PADRE     = max(LV12PADRE,0)
  Endif
  Filter [F:ITK0]

  # ****CÁLCULO DE LA COBERTURA****
  If (LSTKREALITMREF + LSTKREALPADRE - LSTKSOHITMREF - LSTKSOHPADRE) <= 0 Then
    LRET = 0
  Else
    # fórmula indicada por Sergi
    # cobertura = (Stock + SUMA(stock_kits/sub*qty_comp) – pend_pedidos_clientes – SUMA(pend_pedidos_clientes_kits/sub*qty_comp) ) / (ventas_12m + SUMA(ventas_12m_kits/sub*qty_comp)) * 12
    If LV12ITMREF + LV12PADRE > 0 Then
      LRET = ar2(((LSTKREALITMREF + LSTKREALPADRE - LSTKSOHITMREF - LSTKSOHPADRE) / (LV12ITMREF + LV12PADRE)) * 12)
    Elsif LV12ITMREF + LV12PADRE = 0 Then
      LRET = 999
    Else
      LRET = 999
    Endif
  Endif


  Close Local File [ITV0],[ITK0]

End LRET

##############################################################
#**
#* devuelve el porcentaje MB extra
#*
#* @param PS_ITMREF > artículo
#* @param PS_FCY    > planta
#* @param PS_COC    > clasificación oferta cliente
#*!
Funprog GET_MBEXTRA(PS_ITMREF,PS_FCY,PS_COC)
# parámetros de entrada
Value Char PS_ITMREF,PS_FCY,PS_COC

# declaración de variables
Local Decimal LCOB, LRET : Raz LCOB, LRET

  # obtener COBERTURA
  LCOB = func GET_COBERTURA(PS_ITMREF,PS_FCY)

  If !clalev([F:ZMBE])  Then : Local File ZMBEXTRA  [F:ZMBE]  : Endif
  If !clalev([F:XMBE])  Then : Local File ZMBEXTRA  [F:XMBE]  : Endif
  If !clalev([F:ZMBED]) Then : Local File ZMBEXTRAD [F:ZMBED] : Endif
  # búsqueda en la tabla ZMBEXTRA límite cobertura según resultado COB (siempre mayor o igual que el valor de cobertura obtenido)
  Filter [F:ZMBE] Where CLI_1 >= LCOB
  Read [F:ZMBE] First
  If !fstat Then
    # búsqueda en la tabla ZMBEXTRAD según límite cobertura y clasificación oferta cliente
    Read [F:ZMBED]ZMBED0 = [F:ZMBE]CLI_1;PS_COC
    If !fstat Then
      LRET = [F:ZMBED]MBEXTRA
    Endif
  # si la cobertura es mayor que cualquier registro de la tabla ZMBEXTRA, nos quedamos con el último
  # para buscar en la tabla de detalle
  Else
    Read [F:XMBE] Last
    If !fstat Then
      # búsqueda en la tabla ZMBEXTRAD según límite cobertura y clasificación oferta cliente
      Read [F:ZMBED]ZMBED0 = [F:XMBE]CLI_1;PS_COC
      If !fstat Then
        LRET = [F:ZMBED]MBEXTRA
      Endif
    Endif
  Endif
  Filter [F:ZMBE]
  Close Local File [ZMBE],[XMBE],[ZMBED]

End LRET

##############################################################
#**
#* devuelve los precios base
#*
#* @param PS_ITMREF   > artículo
#* @param PS_FCY      > planta
#* @param PS_COC      > clasificación oferta cliente
#* @param PS_CO       > coste oferta
#* @param PS_FRANJA1  > franja 1 de importe
#* @param PS_FRANJA2  > franja 2 de importe
#* @param PS_FRANJA3  > franja 3 de importe
#* @param PS_PRECIO1  > precio por 100 del MB1
#* @param PS_PRECIO2  > precio por 100 del MB2
#* @param PS_PRECIO3  > precio por 100 del MB3
#*!
Subprog GET_PBASE(PS_ITMREF,PS_FCY,PS_COC,PS_CO,PS_FRANJA1,PS_FRANJA2,PS_FRANJA3,PS_PRECIO1,PS_PRECIO2,PS_PRECIO3)
# parámetros de entrada
Value     Char    PS_ITMREF,PS_FCY,PS_COC
# parámetros de salida
Variable  Decimal PS_CO,PS_FRANJA1,PS_FRANJA2,PS_FRANJA3,PS_PRECIO1,PS_PRECIO2,PS_PRECIO3

# declaración de variables
Local Decimal LMBEXTRA
Local Char    LCOA(10)  # clasificación oferta artículo

  # obtener MBEXTRA
  LMBEXTRA = func GET_MBEXTRA(PS_ITMREF,PS_FCY,PS_COC)

  If !clalev([F:ZMBB])  Then : Local File ZMBBASE   [F:ZMBB]  : Endif
  If !clalev([F:ZMBBD]) Then : Local File ZMBBASED  [F:ZMBBD] : Endif
  If !clalev([F:ZITM])  Then : Local File ITMMASTER [F:ZITM]  : Endif

  # búsqueda en tabla ZMMBASE según clasificación oferta artículo
  Read [F:ZITM]ITM0 = PS_ITMREF
  If !fstat Then
    LCOA = [F:ZITM]TSICOD(0)
    Read [F:ZMBB]ZMBB0 = LCOA
    If !fstat Then
      PS_FRANJA1 = [F:ZMBB]FRANJA0
      PS_FRANJA2 = [F:ZMBB]FRANJA1
      PS_FRANJA3 = [F:ZMBB]FRANJA2
    Endif
  Endif

  # búsqueda en tabla ZMBBASED según clasificación oferta artículo y clasificación oferta cliente
  Read [F:ZMBBD]ZMBBD0 = LCOA;PS_COC
  If !fstat Then
    PS_PRECIO1 = (PS_CO*100) / (1-([F:ZMBBD]MB1/100 + LMBEXTRA/100))
    PS_PRECIO2 = (PS_CO*100) / (1-([F:ZMBBD]MB2/100 + LMBEXTRA/100))
    PS_PRECIO3 = (PS_CO*100) / (1-([F:ZMBBD]MB3/100 + LMBEXTRA/100))
#    PS_PRECIO1 = func REDONDEA_ALZA((PS_CO*100) / (1-([F:ZMBBD]MB1/100 + LMBEXTRA/100)),4)
#    PS_PRECIO2 = func REDONDEA_ALZA((PS_CO*100) / (1-([F:ZMBBD]MB2/100 + LMBEXTRA/100)),4)
#    PS_PRECIO3 = func REDONDEA_ALZA((PS_CO*100) / (1-([F:ZMBBD]MB3/100 + LMBEXTRA/100)),4)
  Endif

  Close Local File [ZMBB],[ZMBBD],[ZITM]
End

##############################################################
#**
#* devuelve los precios de la oferta
#*
#* @param PS_ITMREF   > artículo
#* @param PS_FCY      > planta
#* @param PS_COC      > clasificación oferta cliente
#* @param PS_CO       > coste oferta
#* @param PS_CANTIDAD > cantidad
#* @param PS_TIPODOC  > tipo de documento
#* @param PS_POFERTA  > precio oferta
#* @param PS_DTO      > descuento
#*!
Subprog GET_POFERTA(PS_ITMREF,PS_FCY,PS_COC,PS_CO,PS_CANTIDAD,PS_TIPODOC,PS_POFERTA,PS_DTO)
# parámetros de entrada
Value     Char    PS_ITMREF,PS_FCY,PS_COC,PS_TIPODOC
Value     Decimal PS_CO,PS_CANTIDAD

# parámetros de salida
Variable  Decimal PS_POFERTA,PS_DTO

# declaración de variables
Local Decimal LFRANJA1,LFRANJA2,LFRANJA3,LPRECIO1,LPRECIO2,LPRECIO3
Local Decimal LIMPBASE1,LIMPBASE2,LIMPBASE3
Local Decimal LPRECIOBASE
Local Decimal LCANTCAJA
Local Decimal LIMPORTEFIJO
Local Char    LPARAMTIPODOC(20) : LPARAMTIPODOC = func AFNC.PARAM("ZTDOCWEB","")

  # obtener envasado caja
  LCANTCAJA = func CANTIDAD_CAJA(PS_ITMREF)

  # obtener precios base
  Call GET_PBASE(PS_ITMREF,PS_FCY,PS_COC,PS_CO,LFRANJA1,LFRANJA2,LFRANJA3,LPRECIO1,LPRECIO2,LPRECIO3)

  # cálculo importes base
  LIMPBASE1 = (LPRECIO1 * PS_CANTIDAD) / 100
  LIMPBASE2 = (LPRECIO2 * PS_CANTIDAD) / 100
  LIMPBASE3 = (LPRECIO3 * PS_CANTIDAD) / 100

  # asignación precio base
  If LIMPBASE3 > LFRANJA3 Then
    LPRECIOBASE = func REDONDEA_ALZA(LPRECIO3,4)
  Elsif LIMPBASE2 > LFRANJA2 Then
    LPRECIOBASE = func REDONDEA_ALZA(LPRECIO2,4)
  Else
    LPRECIOBASE = func REDONDEA_ALZA(LPRECIO1,4)
  Endif

  # asignacion importe fijo
  If PS_TIPODOC = LPARAMTIPODOC Then
    If mod(PS_CANTIDAD,LCANTCAJA) = 0 Then
      LIMPORTEFIJO = val(func AFNC.PARAM("ZIMPRELINW",""))
    Else
      LIMPORTEFIJO = val(func AFNC.PARAM("ZIMPCONW",""))
    Endif
  Else
    If mod(PS_CANTIDAD,LCANTCAJA) = 0 Then
      LIMPORTEFIJO = val(func AFNC.PARAM("ZIMPPRELIN",""))
    Else
      LIMPORTEFIJO = val(func AFNC.PARAM("ZIMPCON",""))
    Endif
  Endif

  # cálculo precio oferta final
  PS_POFERTA = LPRECIOBASE + ((LIMPORTEFIJO * 100)/PS_CANTIDAD)
  PS_POFERTA = max(val(func AFNC.PARAM("ZIMPMINL","")),(PS_POFERTA * PS_CANTIDAD)/100)
  PS_POFERTA = (PS_POFERTA * 100) / PS_CANTIDAD
  PS_POFERTA = func REDONDEA_ALZA(PS_POFERTA,2)
#  PS_POFERTA = PS_POFERTA / 100

  PS_DTO = 0

End

##############################################################
#**
#* devuelve el valor del importe mínimo para un transportista
#*
#* @param PS_BPT    > código transportista
#* @param PS_HASTAX > límite Hasta X
#*!
Funprog GET_LIMITEBPT(PS_BPT,PS_HASTAX)
Value Char    PS_BPT
Value Integer PS_HASTAX

Local Decimal LRET

  If !clalev([F:ZBPT]) Then : Local File BPCARRIER [F:ZBPT] : Endif
  Read [F:ZBPT]BPT0 = PS_BPT
  If !fstat Then
    Case PS_HASTAX
      When 3 : LRET = [F:ZBPT]TSDFRE(0)
      When 4 : LRET = [F:ZBPT]TSDFRE(1)
      When 5 : LRET = [F:ZBPT]TSDFRE(2)
      When 6 : LRET = [F:ZBPT]TSDFRE(3)
      When 7 : LRET = [F:ZBPT]TSDFRE(4)
      When Default
    Endcase
  Endif
  Close Local File [ZBPT]

End LRET

##############################################################
#**
#* bloquea un documento
#*
#* @param PS_ACTIONTYP  > tipo de acción ; "D" desbloquea  , "B" bloquea
#* @param PS_VCRTYP     > tipo de documento
#* @param PS_VCRNUM     > número documento
#*!
Funprog DLOCK_DOC(PS_ACTIONTYP,PS_VCRTYP,PS_VCRNUM)
Value Char  PS_ACTIONTYP,PS_VCRTYP, PS_VCRNUM

#  Case PS_VCRTYP
#    When "SOH"
#      If !clalev([F:ZSOH]) Then : Local File SORDER   [F:ZSOH] : Endif
#      Read [F:ZSOH]SOH0 = PS_VCRNUM
#      If !fstat Then
#        Trbegin [F:ZSOH]
#        If PS_ACTIONTYP   = "B" Then
#          [F:ZSOH]HLDSTA  = 2
#          [F:ZSOH]HLDCOD  = "PORTES"
#          [F:ZSOH]HLDDAT  = date$
#          [F:ZSOH]HLDTIM  = datetime$
#          [F:ZSOH]HLDUSR  = GUSER
#        Elsif PS_ACTIONTYP = "D" Then
#          If [F:ZSOH]HLDCOD  = "PORTES" Then
#            [F:ZSOH]HLDSTA  = 1
#            [F:ZSOH]HLDCOD  = ""
#            [F:ZSOH]HLDDAT  = [00/00/0000]
#            [F:ZSOH]HLDTIM  = [00/00/0000]
#            [F:ZSOH]HLDUSR  = ""
#          Endif
#        Endif
#        Rewrite [F:ZSOH]
#        If !fstat Then
#          Commit
#        Else
#          Rollback
#        Endif
#      Endif
#      Close Local File [ZSOH]
#  Endcase

End ""

##############################################################
#MODIF RPES  20201130  VTAS078 Multiple de caja
Funprog ACEPTA_CANT_JUSTA(PS_ITMREF)
Value Char PS_ITMREF

Local File ITMMASTER [ITM]

Read [F:ITM]ITM0 = PS_ITMREF
If fstat = 0 Then
  End [ITM]ZCANTJUSTA
Endif

End 0

##############################################################
#MODIF RPES  20201130  VTAS078 Multiple de caja
Funprog NO_MULTIPLO_CAJA(PS_ITMREF, PF_QTY, PF_COEF)
Value Char PS_ITMREF
Value Decimal PF_QTY
Variable Decimal PF_COEF

Local File ITMMASTER  [ITM]
Local File ITMFACILIT [ITF]

Local Integer I_QTY
Local Decimal F_QTY_UOM

Read [F:ITF]ITF0 = PS_ITMREF;"PHISP"
If fstat = 0 and [F:ITF]STOMGTCOD <> 1 Then

  Read [F:ITM]ITM0 = PS_ITMREF
  If fstat = 0
    For I = 0 To dim([F:ITM]PCU)
      If [F:ITM]PCU(I) = "CAJ" Then
        PF_COEF = [F:ITM]PCUSTUCOE(I)
        If [F:ITM]PCUSTUCOE(I) <> 0 Then
          [L]F_QTY_UOM = PF_QTY / [F:ITM]PCUSTUCOE(I)
        Endif
        [L]I_QTY = [L]F_QTY_UOM
        If [L]I_QTY = [L]F_QTY_UOM Then
          End 2
        Else
          End 1
        Endif
      Endif
    Next
  Endif

Endif

End 0

##############################################################
#**
#* desasigna un pedido
#*
#* @param NUM     > nº pedido
#* @param LIN     > nº línea pedido
#* @param SEQ     > nº seq pedido
#* @param LSTOFCY > planta
#* @param LSHIDAT > fecha expedición
#*!
Subprog UPD_DEASIG_SOH(NUM,LIN,SEQ,LSTOFCY,LSHIDAT)
Value Char NUM,LSTOFCY
Value Integer LIN,SEQ
Value Date    LSHIDAT
Local Integer FGSERVEUR : FGSERVEUR=GSERVEUR
  GSERVEUR = 1
  Gosub INIT From FUNDESALL
  [M:DIA]STOFCY = LSTOFCY
  [M:DIA]SHIDAT = LSHIDAT
  [M:DIA]SOHNUMDEB = NUM
  [M:DIA]SOHNUMFIN = NUM
  [M:DIA]ALLCRITENT = "[F:SOQ]SOPLIN="+ num$(LIN)
  Gosub EXEC From FUNDESALL
  Gosub TERMINE From FUNDESALL
  GSERVEUR = FGSERVEUR
End

##############################################################
#**
#* asigna un pedido
#*
#* @param NUM     > nº pedido
#* @param LIN     > nº línea pedido
#* @param SEQ     > nº seq pedido
#* @param LSTOFCY > planta
#* @param LSHIDAT > fecha expedición
#*!
Subprog UPD_ASIG_SOH(NUM,LIN,SEQ,LSTOFCY,LSHIDAT)
Value Char NUM,LSTOFCY
Value Integer LIN,SEQ
Value Date    LSHIDAT
Local Integer FGSERVEUR : FGSERVEUR=GSERVEUR
Local Char PARAM(60)(7)
  PARAM(1) = LSTOFCY
  PARAM(2) = LSHIDAT
  PARAM(3) = NUM
  PARAM(6) = "[F:SOQ]SOPLIN="+ num$(LIN)
  GSERVEUR = 1
  Gosub INIT From FUNAUTALL
  Gosub EXEC From FUNAUTALL
  Gosub TERMINE From FUNAUTALL
  GSERVEUR = FGSERVEUR
End

##############################################################
#**
#* borra todos los caracteres indicados en el parámetro PCHAR a la izquierda de la cadena PSTRING
#*
#* @param PSTRING > cadena
#* @param PCHAR   > caracter a borrar
#*!
Funprog DEL_LEFT_CHARS(PSTRING,PCHAR)
Value Char    PSTRING,PCHAR
Local Integer LCON,LNUMCHARS
Local Char    LPIECE(250)
  For LCON=1 To len(PSTRING)
    LPIECE = mid$(PSTRING,LCON,1)
    If LPIECE = PCHAR Then
      LNUMCHARS += 1
    Else
      Break
    Endif
  Next
End mid$(PSTRING,LNUMCHARS+1,len(PSTRING))

###############################################################################
#**
#* Crear .job para la importación de ficheros csv
#*
#* @param ZMODIMP   > modelo de importación utilizado
#* @param ZNOMIMP   > fichero a importar (ruta incluida)
#* @param ZVOLFIL   > fichero a importar (ruta espacio almacenamiento incluida)
#* @param ZRUTAJOB  > fichero job (ruta incluida)
#*!
Funprog CREAR_JOB(ZMODIMP,ZNOMIMP,ZVOLFIL,ZRUTAJOB)
Value Char ZMODIMP
Value Char ZNOMIMP
Value Char ZVOLFIL
Value Char ZRUTAJOB

  Openo ZRUTAJOB

  Wrseq 'DOSSIER='+[S]nomap(0)
  Wrseq 'UTIL=ADMIN'
  Wrseq 'PASSE=BAABAA'
  Wrseq 'GRP='
  Wrseq 'TACHE=IMPORT'
  Wrseq 'DATE=20180101'
  Wrseq 'HEURE=0001'
  Wrseq 'MODIMP=' + ZMODIMP
  Wrseq 'NOMIMP=' + ZNOMIMP
  Wrseq 'TYPEXP=2'
  Wrseq 'VOLFIL=' + ZVOLFIL
  Wrseq 'ZMODIMP=Import_desde_JOB'

  Openo

End

###############################################################################
#**
#* Analiza el fichero .sta que se genera después del .job
#* para ver cómo ha finalizado el proceso
#*
#* @param PFILESTA  > ruta del fichero .sta
#* @param PTYPE     > tipo de mensaje: 0=mensaje ; 1=error
#* @param PMESS     > mensaje tras procesar la petición
#* @param PTRA      > fichero traza
#*!
Subprog GESTION_FILE_STA(PFILESTA,PTYPE,PMESS,PTRA)
Value     Char    PFILESTA
Variable  Integer PTYPE
Variable  Char    PMESS,PTRA

Local Char    LESTADO(5),LNUMPETICION(8),LFECHAINI(14),LFECHAFIN(14),LCODDOSIER(10),LCODUSER(5),LCODTAR(10),LMSG(80),LCOMPLEMENTO(1),LMESS(250)
Local Integer LCONT,LSALIR,LCONTROL

  LSALIR = 1

  While LSALIR = 1 and LCONT <= 50           # espera 50 segundos antes de detener el proceso por TIMEOUT

    If filinfo(PFILESTA, 7) <= 0 Then
      PTYPE = 4
      PMESS = "La solicitud de actualización de PA no se ha procesado"
      LCONT += 1
      Sleep 1
    Else
      # Abre fichero original para leer
      Openi   PFILESTA                  Using [ZIMP_R]
      Iomode  adxirs chr$(13)+chr$(10)  Using [ZIMP_R]
      Iomode  adxium 50                 Using [ZIMP_R] # 50 = ASCII 0 = UTF8
      Iomode  adxifs ":"                Using [ZIMP_R]

      LECOK = 1
      Repeat
        # lee el archivo
        Rdseq LESTADO,LNUMPETICION,LFECHAINI,LFECHAFIN,LCODDOSIER,LCODUSER,LCODTAR,LMSG  Using [ZIMP_R]
        If !fstat Then
          PTRA = "RQT"+LNUMPETICION
          If left$(LESTADO,1) = "0" Then
            PTYPE  = 0
            If mid$(LESTADO,2,4) = "0000"
              PMESS     = "Proceso de actualización de PA finalizado correctamente"
            Else
              PTYPE = 5
              PMESS     = "Proceso de actualización de PA finalizado con " + num$(val(mid$(LESTADO,2,4))) + " avisos"
            Endif
          Elsif left$(LESTADO,1) = "1" Then
            PTYPE      = 1
            Case mid$(LESTADO,2,1)
              When "0"  : PMESS = "Petición terminada de actualización de PA con un error desconocido"
              When "1"  : PMESS = "Fin de actualización de PA por error número " + mid$(LESTADO,3,3) + " en Adonix:" - LMSG
              When "2"  : PMESS = "Actualización de PA . Error de bloqueo"
              When "3"  : PMESS = "Petición de actualización de PA terminada con un error " + mid$(LESTADO,3,3) + " de tratamiento" - GMESSBATCH - LMSG
            Endcase
          Elsif left$(LESTADO,1) = "2" Then
            PTYPE = 2
            Case mid$(LESTADO,2,4)
              When "1000"  : PMESS = "La tarea se ha programado para una hora dada, pero no ha podido lanzarse en los plazos previstos"
              When "2000"  : PMESS = "Tarea inexistente"
              When "3000"  : PMESS = "Tratamiento no lanzado por problema de habilitación especificada"
              When "3100"  : PMESS = "Usuario desconocido"
              When "3200"  : PMESS = "Contraseña incorrecta"
              When "3300"  : PMESS = "Tratamiento no lanzado por habilitación rechazada por punto de entrada"
              When "3400"  : PMESS = "Nivel de acceso no autorizado al usuario"
              When "3500"  : PMESS = "Función no autorizada al usuario"
              When "5000"  : PMESS = "Tratamiento inexistente"
            Endcase
          Else
            PTYPE = 3
            PMESS = "Petición de actualización de PA interrumpida"
          Endif
        Else
          LECOK = 0
        Endif
      Until LECOK = 0
      LSALIR = 0
    Endif
  Wend

End

#######################
#**
#* convierte divisas
#*
#* @param PDIVISAORI  > divisa origen
#* @param PDIVISADES  > divisa destino
#* @param PCANTIDAD   > cantidad a cambiar
#* @param PTIPO       > tipo de cambio (1=cambio día; 2=cambio mes; 3=cambio medio; 4=cambio DEB)
#* @param PCAMBIO     > valor del cambio
#*!
Subprog CONVERTDIV(PDIVISAORI,PDIVISADES,PCANTIDAD,PTIPO,PCAMBIO)
Value     Char    PDIVISAORI
Value     Char    PDIVISADES
Value     Decimal PCANTIDAD
Value     Integer PTIPO
Variable  Decimal PCAMBIO

  If PDIVISAORI = PDIVISADES Then
    PCAMBIO = PCANTIDAD
    End
  Endif

  If !clalev([F:TCH0]) Then : Local File TABCHANGE  [F:TCH0] : Endif

  Filter [F:TCH0] Where CHGTYP = PTIPO and CURDEN = PDIVISADES and CUR = PDIVISAORI and date$ >= CHGSTRDAT Order By CHGSTRDAT Desc
  Read [F:TCH0] First
  If !fstat Then
    PCAMBIO = (PCANTIDAD * [F:TCH0]CHGRAT)
  Endif
  Filter [F:TCH0]
  If  clalev([F:TCH0]) Then : Close Local File      [F:TCH0] : Endif

End

#######################
#**
#* convierte divisas en una fecha
#*
#* @param PDIVISAORI  > divisa origen
#* @param PDIVISADES  > divisa destino
#* @param PCANTIDAD   > cantidad a cambiar
#* @param PTIPO       > tipo de cambio (1=cambio día; 2=cambio mes; 3=cambio medio; 4=cambio DEB)
#* @param PCAMBIO     > valor del cambio
#*!
Subprog CONVERTDIV_DATE(PDIVISAORI,PDIVISADES,PCANTIDAD,PTIPO,PDATE,PCAMBIO)
Value     Char    PDIVISAORI
Value     Char    PDIVISADES
Value     Decimal PCANTIDAD
Value     Integer PTIPO
Value     Date    PDATE
Variable  Decimal PCAMBIO

  If PDIVISAORI = PDIVISADES Then
    PCAMBIO = PCANTIDAD
    End
  Endif

  If !clalev([F:TCH0]) Then : Local File TABCHANGE  [F:TCH0] : Endif

  Filter [F:TCH0] Where CHGTYP = PTIPO and CURDEN = PDIVISADES and CUR = PDIVISAORI and PDATE >= CHGSTRDAT Order By CHGSTRDAT Desc
  Read [F:TCH0] First
  If !fstat Then
    PCAMBIO = (PCANTIDAD * [F:TCH0]CHGRAT)
  Endif
  Filter [F:TCH0]
  If  clalev([F:TCH0]) Then : Close Local File      [F:TCH0] : Endif

End

##############################################################
#**
#* sustituye un caracter por una cadena de caracteres
#*
#* @param STR > cadena
#* @param OLD   > caracter/es a borrar
#* @param NEW   > caracter/es a sustituir
#*!
Funprog REPLACE(STR, OLD, NEW)
    Value Clbfile STR()
    Value Char OLD()
    Value Char NEW()
    Local Integer LENOLD
    Local Integer LENNEW

    #length of string to substitute
    LENOLD= len(OLD)
    #length of string that will substitute OLD string
    LENNEW= len(NEW)

    If LENOLD<=0 or LENOLD>len(STR)
        #the string to substitute is empty or it is longer than initial string, so we do nothing
        End STR
    Endif
    Local Integer INDEX
    Local Integer INDEXSTART

    #We search the string to substitute
    INDEX=instr(1,STR,OLD)

    While INDEX>0
        #INDEX>0 this means that we have found an occurrence of OLD
        #We substitute OLD occurrence with the NEW string
        STR =left$(STR, INDEX-1) + NEW + right$(STR, INDEX+LENOLD)

        #We calc the index to which the NEW string just inserted ends
        INDEXSTART=INDEX+LENNEW

        #We search the string to substitute starting from the end of last found occurrence
        INDEX=instr(INDEXSTART,STR,OLD)
    Wend
End STR

#######################
#**
#* limpia caracteres extraños en una cadena
#*
#* @param PCHARIN   > cadena a limpiar
#* @param PCHAROUT  > cadena limpia
#*!
Subprog LIMPIA_STR(PCHARIN,PCHAROUT)
Value     Clbfile  PCHARIN
Variable  Clbfile  PCHAROUT

Local Clbfile PSTR(3) : PSTR=PCHARIN

  PSTR=func REPLACE(PSTR,"Ã¡" ,"a") : PSTR=func REPLACE(PSTR,"Ã " ,"a") : PSTR=func REPLACE(PSTR,"Ã¤" ,"a")
  PSTR=func REPLACE(PSTR,"Ã¢" ,"a") : PSTR=func REPLACE(PSTR,"Âª" ,"a") : PSTR=func REPLACE(PSTR,"Ã?" ,"A")
  PSTR=func REPLACE(PSTR,"Ã€" ,"A") : PSTR=func REPLACE(PSTR,"Ã‚" ,"A") : PSTR=func REPLACE(PSTR,"Ã„" ,"A")
  PSTR=func REPLACE(PSTR,"Ã©" ,"e") : PSTR=func REPLACE(PSTR,"Ã¨" ,"e") : PSTR=func REPLACE(PSTR,"Ã«" ,"e")
  PSTR=func REPLACE(PSTR,"Ãª" ,"e") : PSTR=func REPLACE(PSTR,"Ã‰" ,"E") : PSTR=func REPLACE(PSTR,"Ãˆ" ,"E")
  PSTR=func REPLACE(PSTR,"ÃŠ" ,"E") : PSTR=func REPLACE(PSTR,"Ã‹" ,"E") : PSTR=func REPLACE(PSTR,"Ã­" ,"i")
  PSTR=func REPLACE(PSTR,"Ã¬" ,"i") : PSTR=func REPLACE(PSTR,"Ã¯" ,"i") : PSTR=func REPLACE(PSTR,"Ã®" ,"i")
  PSTR=func REPLACE(PSTR,"Ã?" ,"I") : PSTR=func REPLACE(PSTR,"ÃŒ" ,"I") : PSTR=func REPLACE(PSTR,"Ã?" ,"I")
  PSTR=func REPLACE(PSTR,"ÃŽ" ,"I") : PSTR=func REPLACE(PSTR,"Ã³" ,"o") : PSTR=func REPLACE(PSTR,"Ã²" ,"o")
  PSTR=func REPLACE(PSTR,"Ã¶" ,"o") : PSTR=func REPLACE(PSTR,"Ã´" ,"o") : PSTR=func REPLACE(PSTR,"Ã“" ,"O")
  PSTR=func REPLACE(PSTR,"Ã’" ,"O") : PSTR=func REPLACE(PSTR,"Ã–" ,"O") : PSTR=func REPLACE(PSTR,"Ã”" ,"O")
  PSTR=func REPLACE(PSTR,"Ãº" ,"u") : PSTR=func REPLACE(PSTR,"Ã¹" ,"u") : PSTR=func REPLACE(PSTR,"Ã¼" ,"u")
  PSTR=func REPLACE(PSTR,"Ã»" ,"u") : PSTR=func REPLACE(PSTR,"Ãš" ,"U") : PSTR=func REPLACE(PSTR,"Ã™" ,"U")
  PSTR=func REPLACE(PSTR,"Ã›" ,"U") : PSTR=func REPLACE(PSTR,"Ãœ" ,"U") : PSTR=func REPLACE(PSTR,"Ã±" ,"n")
  PSTR=func REPLACE(PSTR,"Ã‘" ,"N") : PSTR=func REPLACE(PSTR,"Ã§" ,"c") : PSTR=func REPLACE(PSTR,"Ã‡" ,"C")
  PSTR=func REPLACE(PSTR,"\" ,"")   : PSTR=func REPLACE(PSTR,"Â¨" ,"")  : PSTR=func REPLACE(PSTR,"Âº" ,"")
  PSTR=func REPLACE(PSTR,"~" ,"")   : PSTR=func REPLACE(PSTR,"#" ,"")   : PSTR=func REPLACE(PSTR,"@" ,"")
  PSTR=func REPLACE(PSTR,"|" ,"")   : PSTR=func REPLACE(PSTR,"!" ,"")   : PSTR=func REPLACE(PSTR,'"' ,"")
  PSTR=func REPLACE(PSTR,"*" ,"")   : PSTR=func REPLACE(PSTR,"Â·" ,"")  : PSTR=func REPLACE(PSTR,"$" ,"")
  PSTR=func REPLACE(PSTR,"%" ,"")   : PSTR=func REPLACE(PSTR,"&" ,"")   : PSTR=func REPLACE(PSTR,"(" ,"")
  PSTR=func REPLACE(PSTR,")" ,"")   : PSTR=func REPLACE(PSTR,"?" ,"")   : PSTR=func REPLACE(PSTR,"'" ,"")
  PSTR=func REPLACE(PSTR,"Â¡" ,"")  : PSTR=func REPLACE(PSTR,"Â¿" ,"")  : PSTR=func REPLACE(PSTR,"[" ,"")
  PSTR=func REPLACE(PSTR,"^" ,"")   : PSTR=func REPLACE(PSTR,"<" ,"")   : PSTR=func REPLACE(PSTR,">" ,"")
  PSTR=func REPLACE(PSTR,"]" ,"")   : PSTR=func REPLACE(PSTR,"+" ,"")   : PSTR=func REPLACE(PSTR,"}" ,"")
  PSTR=func REPLACE(PSTR,"{" ,"")   : PSTR=func REPLACE(PSTR,"Â´" ,"")  : PSTR=func REPLACE(PSTR,";" ,"")
  PSTR=func REPLACE(PSTR,":" ,"")   : PSTR=func REPLACE(PSTR,"." ,"")   : PSTR=func REPLACE(PSTR,"/" ,"")

  PCHAROUT = PSTR

End

##############################################################
#**
#* sustituye un caracter por una cadena de caracteres
#*
#* @param PTYPE   > tipo de documento
#* @param PNUMDOC > número de documento
#*!
Funprog COMPRUEBA_BLOQUEO(PTYPE,PNUMDOC)
Value Char PTYPE,PNUMDOC

Local Integer LRET      # lret = 0 -> no bloqueo ; lret = 1 -> sí bloqueo

  If !clalev([F:ZALK]) Then : Local File APLLCK [F:ZALK] : Endif
  Filter [F:ZALK] Where LCKSYM = PTYPE+PNUMDOC
  Read [F:ZALK] First
  If !fstat Then
    LRET = 1
  Else
    LRET = 0
  Endif
  Close Local File [ZALK]
End

#########################################################################
# Subprog TRANSPORT : Calcul des frais de port (tarifs transporteurs)   #
#-----------------------------------------------------------------------#
# Transporteur                                                          #
# Client  (pour les conditions : franco, facturÃ©, ou le seuil utilisÃ©)#
# Site d'expÃ©dition                                                    #
# Pays, Ville, Code postal de destination                               #
# Devise, Type de cours, Date du cours                                  #
# Montant HT (utilisÃ© pour test du seuil)                              #
# UnitÃ© de poids, Poids                                                #
# UnitÃ© de volume, Volume (pour calcul du poids volumique)             #
#-----------------------------------------------------------------------#
# Retour                                                                #
# RÃ©gion de tarification (si tarif par rÃ©gions)                       #
# Montant des frais (dans la devise demandÃ©e)                          #
# Code retour (si aucun frais)                                          #
#   1 = pas de tiers / 2 = pas de transporteur / 3 = tarif inactif      #
#   4 = application du seuil / 5 = franco de port                       #
#########################################################################

Subprog TRANSPORT (BPTNUM,BPCNUM,ZFREINV,STOFCY,CRY,POSCTY,POSCOD,CUR,CHGTYP,CHGDAT,AMTNOT,
&                  WEU,GROWEI,VOU,VOL,BPTARE,AMTFRE,FRELIB,STAT)
Value    Char    BPTNUM ()
Value    Char    BPCNUM ()
Value    Integer ZFREINV                                              # este parámetro lo he añadido
Value    Char    STOFCY ()
Value    Char    CRY ()
Value    Char    POSCTY ()
Value    Char    POSCOD ()
Value    Char    CUR ()
Value    Integer CHGTYP
Value    Date    CHGDAT
Value    Decimal AMTNOT
Value    Char    WEU ()
Value    Decimal GROWEI
Value    Char    VOU ()
Value    Decimal VOL
Variable Char    BPTARE ()
Variable Decimal AMTFRE
Variable Char    FRELIB () (0..)
Variable Integer STAT

Local Integer WCHGTYP    : # type de cours
Local Date    WCHGDAT    : # date du cours
Local Decimal WAMTNOT    : # montant pour test seuil
Local Decimal WGROWEI    : # poids
Local Decimal WVOL       : # volume (pour calcul poids volumique)
Local Decimal WVOL1      : # volume (pour calcul poids volumique)
Local Char    WPOSCOD    : # code postal (pour recherche de la rÃ©gion)
Local Integer WLEN       : # longueur du code postal (pour recherche de la region)

Local Char    CURBPT     : # devise du transporteur (donc des tarifs)
Local Decimal CURRNDBPT  : # code arrondi de la devise transporteur
Local Integer DECNBRBPT  : # nombre de dec. de devise transporteur
Local Char    FORMAT     : # formatage des montants
Local Char    FORMATV    : # formatage des montants si nb dec. > nb dec. devise transporteur
Local Decimal POIDS_P    : # poids converti en unitÃ© poids du tarif
Local Decimal POIDS_V    : # poids volumique converti en unitÃ© poids du tarif
Local Decimal POIDS_CPP  : # poids restant pour calcul poids proportionnel
Local Decimal POIDS      : # poids utilisÃ© pour le calcul (le + important)
Local Decimal SEUIL      : # valeur du seuil en fonction paramÃ¨tre du client
Local Decimal COEF
Local Integer ILIB, IDEC, IJL

Local Char    LIBCONPV (150)        : # si conversion volume -> poids (poids volumique)
Local Char    LIBNCAL  (150)        : # pas de calcul erreur ou seuil
Local Char    LIBFIX   (150)        : # montant fixe
Local Char    LIBFIXR  (150)        : # montant fixe par rÃ©gion
Local Char    LIBPRO1  (150)        : # montant proportionnel
Local Char    LIBPRO2  (150)        : # montant proportionnel (suite)
Local Char    LIBPROR1 (150)        : # montant proportionnel par rÃ©gion
Local Char    LIBPROR2 (150)        : # montant proportionnel par rÃ©gion (suite)
Local Char    LIBCONVD (150)        : # si conversion devise
Local Char    LIBUSER  (150) (0..9) : # libelle libre utilisateur (10 lignes )

WAMTNOT=AMTNOT : WCHGTYP=CHGTYP : WCHGDATE=CHGDAT
WGROWEI=GROWEI : WVOL1=VOL
Raz STAT
Raz LIBCONPV, LIBNCAL, LIBFIX, LIBFIXR, LIBPRO1, LIBPRO2, LIBPROR1, LIBPROR2, LIBCONVD

If clalev([F:BPR])=0 : Local File BPARTNER   [BPR] : Endif
If clalev([F:BPC])=0 : Local File BPCUSTOMER [BPC] : Endif
If clalev([F:BPT])=0 : Local File BPCARRIER  [BPT] : Endif
If clalev([F:CAA])=0 : Local File CARAREA    [CAA] : Endif
If clalev([F:CAP])=0 : Local File CARPRICE   [CAP] : Endif
If clalev([F:TCY])=0 : Local File TABCOUNTRY [TCY] : Endif
If clalev([F:TCO])=0 : Local File TABCOEFF   [TCO] : Endif
If clalev([F:TCU])=0 : Local File TABCUR     [TCU] : Endif

# ACA (2010-03-10) Bug 63210 : On vÃ©rifie si le transporteur est fournit
If [L]BPTNUM=""
  Raz [L]BPTARE : Raz AMTFRE : STAT=1 : End
Endif

#--- lecture du tiers (pour avoir la devise)
If [F:BPR]BPRNUM <> [L]BPTNUM
  Read [BPR]BPR0 = [L]BPTNUM
  If fstat : Raz [L]BPTARE : Raz AMTFRE : STAT=1 : End : Endif
Endif
#--- lecture du transporteur
If [F:BPT]BPTNUM <> [L]BPTNUM
  Read [BPT]BPT0 = [L]BPTNUM
  If fstat : Raz [L]BPTARE : Raz AMTFRE : STAT=2 : End : Endif
Endif
#    si tarif transporteur inactif --> fin
If [F:BPT]PLIFLG<>2
  Raz [L]BPTARE : Raz AMTFRE
  STAT=3 : End
Endif

[L]CURBPT=[F:BPT]CUR
#--- lecture devise transporteur pour arrondi
If [F:TCU]CUR <> [L]CURBPT
  Read [TCU]TCU0 = [L]CURBPT
  If fstat : Raz [L]BPTARE : Raz AMTFRE : STAT=1 : End : Endif
Endif
[L]CURRNDBPT=[F:TCU]CURRND : [L]DECNBRBPT=[F:TCU]DECNBR

FORMAT="N<:11.2#"
If [L]CUR=[L]CURBPT & dim(GDEVFMT1)
  FORMAT="N<:"+GDEVFMT1
Endif

#--- si prÃ©sence du client on charge le seuil
#    convertir le montant en devise du seuil fournisseur
If [L]BPCNUM<>"" & [F:BPC]BPCNUM <> [L]BPCNUM
   Read [BPC]BPC0 = [L]BPCNUM
Endif

Local Integer WPE_WEIVOL : WPE_WEIVOL=0

Raz LIBNCAL
If [L]BPCNUM<>""
#  Case [F:BPC]FREINV                                                     # esta parte es la que modifico
  Case ZFREINV
    When 1  : SEUIL = 999999999.99     : # facturÃ©
    When 2  : SEUIL = 0                : # franco pas de calcul
              Raz [L]BPTARE : Raz AMTFRE
              LIBNCAL = mess(159,196,1)
              Gosub EXPLICATION
              STAT=5 : End
    When 3  : SEUIL = [F:BPT]TSDFRE(0) : # seuil 1
    When 4  : SEUIL = [F:BPT]TSDFRE(1) : # seuil 2
    When 5  : SEUIL = [F:BPT]TSDFRE(2) : # seuil 3
    When 6  : SEUIL = [F:BPT]TSDFRE(3) : # seuil 4
    When 7  : SEUIL = [F:BPT]TSDFRE(4) : # seuil 5
  Endcase

#    il faut faire le test du seuil
  If SEUIL<>0 & WAMTNOT<>0
#   devise du montant diffÃ©rent de celui des seuils
    If [L]CUR<>[L]CURBPT
      If WCHGTYP=0          : WCHGTYP=1     : Endif
      If WCHGDAT=[00/00/00] : WCHGDAT=date$ : Endif
      Call CONVERT([L]CUR,[L]CURBPT,GLOCALDEV,WCHGTYP,WCHGDAT,WAMTNOT,WAMTNOT,GBIDI3) From TRTDEV
    Endif
#   montant supÃ©rieur au seuil --> pas de frais de transport
    If WAMTNOT>=SEUIL
#               Port Ã©xonÃ©rÃ© : montant supÃ©rieur au seuil $1$ $2$
#                 $1$ = valeur du seuil
#                 $2$ = devise du tarif
      LIBNCAL = mess(14,185,1)
      Call DYNAMIC(LIBNCAL,"$1$",format$(FORMAT,SEUIL)) From TEXTE
      Call DYNAMIC(LIBNCAL,"$2$",CURBPT) From TEXTE
      Raz [L]BPTARE : Raz AMTFRE
      Gosub EXPLICATION
      STAT=4 : End
    Endif
  Endif
Endif

#--- le poids doit Ãªtre dans unitÃ© du transporteur : sinon conversion
If [L]WEU<>[F:BPT]WEU
  Call CALCUL_QTY(WGROWEI,[L]WEU,WGROWEI,[F:BPT]WEU,COEF) From TRTX3
Endif

#--- si volume doit Ãªtre dans unitÃ© du transporteur : sinon conversion
If [L]VOU<>""
  If [L]VOU<>[F:BPT]VOU
    Call CALCUL_QTY(WVOL1,[L]VOU,WVOL1,[F:BPT]VOU,COEF) From TRTX3
  Endif
Else
  WVOL1=0
Endif

#--- on prend le poids le plus grand : poids et Ã©ventuel poids volumique
#    si WPE_WEIVOL=1 on prend toujours le poids volumique
#    si absence de poids fin (Ã  voir)
Raz LIBCONPV
If WVOL1<>0 & [F:BPT]COEWEIVOL<>0
  WVOL=WVOL1*[F:BPT]COEWEIVOL
  If WVOL>WGROWEI | WPE_WEIVOL=1
    WGROWEI=WVOL
#              Utilisation du coefficient de correspondance poids volume : $1$ $2$ * $3$ = $4$ $5$
#                $1$ = volume dans l'unitÃ© du tarif
#                $2$ = unitÃ© de volume du tarif
#                $3$ = coefficient de conversion poids/volume
#                $4$ = poids calculÃ©
#                $5$ = unitÃ© de poids du tarif
    LIBCONPV = mess(15,185,1)
    Call DYNAMIC(LIBCONPV,"$1$",num$(WVOL1)) From TEXTE
    Call DYNAMIC(LIBCONPV,"$2$",[F:BPT]VOU) From TEXTE
    Call DYNAMIC(LIBCONPV,"$3$",num$([F:BPT]COEWEIVOL)) From TEXTE
    Call DYNAMIC(LIBCONPV,"$4$",num$(WGROWEI)) From TEXTE
    Call DYNAMIC(LIBCONPV,"$5$",[F:BPT]WEU) From TEXTE
  Endif
Endif

#--- recherche de la rÃ©gion
Raz [L]BPTARE
WPOSCOD=POSCOD
WLEN=len(WPOSCOD)
While WLEN >=0
  Read [F:CAA]CAA1=[L]BPTNUM;STOFCY;[L]CRY;WPOSCOD
  If !fstat
    [L]BPTARE=[F:CAA]BPTARE : Break
  Endif
  If len(WPOSCOD)>0
    WPOSCOD=left$(WPOSCOD,len(WPOSCOD)-1)
  Endif
  WLEN -=1
Wend

#    recherche sans tenir compte du site d'expÃ©dition (si non trouvÃ© avant)
If [L]BPTARE=""
  WPOSCOD=POSCOD
  WLEN=len(WPOSCOD)
  While WLEN >=0
    Read [F:CAA]CAA1=[L]BPTNUM;"";[L]CRY;WPOSCOD
    If !fstat
      [L]BPTARE=[F:CAA]BPTARE : Break
    Endif
    If len(WPOSCOD)>0
      WPOSCOD=left$(WPOSCOD,len(WPOSCOD)-1)
    Endif
    WLEN -=1
  Wend
Endif

Raz LIBFIX, LIBFIXR, LIBPRO1, LIBPRO2, LIBPROR1, LIBPROR2

#--- montant fixe
AMTFRE=[F:BPT]FXDAMT
If [F:BPT]FXDAMT<>0
#          Montant fixe = $1$ $2$
#            $1$ = montant
#            $2$ = devise du tarif
  LIBFIX = mess(16,185,1)
  Call DYNAMIC(LIBFIX,"$1$",format$(FORMAT,[F:BPT]FXDAMT)) From TEXTE
  Call DYNAMIC(LIBFIX,"$2$",[L]CURBPT) From TEXTE
Endif
#--- montant proportionnel initial = poids total
POIDS_CPP = WGROWEI

#--- montant par rÃ©gion
Raz [CAP]
Filter [CAP] Where BPTNUM=[L]BPTNUM & BPTARE=[L]BPTARE
&                & [L]WGROWEI>=MINQTY & [L]WGROWEI<=MAXQTY
&            Order By Key CAP2
Read [CAP]CAP2 First
If !fstat
  POIDS_CPP -= [F:CAP]MINQTY
  AMTFRE += [F:CAP]PRI

  If [F:CAP]PRI<>0
#             Montant fixe par rÃ©gion pour un poids de $1$ Ã  $2$ $3$ = $4$ $5$
#               $1$ = borne infÃ©rieure de poids (borne comprise)
#               $2$ = borne supÃ©rieure de poids (borne comprise)
#               $3$ = unitÃ© de poids du tarif
#               $4$ = montant
#               $5$ = devise du tarif
#               $6$ = rÃ©gion (tag non utilisÃ© actuellement dans message)
    LIBFIXR = mess(17,185,1)
    Call DYNAMIC(LIBFIXR,"$1$",num$([F:CAP]MINQTY)) From TEXTE
    Call DYNAMIC(LIBFIXR,"$2$",num$([F:CAP]MAXQTY)) From TEXTE
    Call DYNAMIC(LIBFIXR,"$3$",[F:BPT]WEU) From TEXTE
    Call DYNAMIC(LIBFIXR,"$4$",format$(FORMAT,[F:CAP]PRI)) From TEXTE
    Call DYNAMIC(LIBFIXR,"$5$",[L]CURBPT) From TEXTE
    Call DYNAMIC(LIBFIXR,"$6$",[L]BPTARE) From TEXTE
  Endif

  If [F:CAP]BKT<>0 & [F:CAP]ADL<>0
    NBTRANCHES=(WGROWEI-[F:CAP]MINQTY)/[F:CAP]BKT
    Case [F:CAP]WEIRND
      When 1       : NBTRANCHES=int(NBTRANCHES)
      When 2       : NBTRANCHES=int(NBTRANCHES+0.999999)
      When Default : NBTRANCHES=arr(NBTRANCHES,1)
    Endcase
    AMTFRE += arr([F:CAP]ADL*NBTRANCHES,[L]CURRNDBPT)

    If [F:CAP]ADL*NBTRANCHES <>0

#                Montant proportionnel par rÃ©gion de $1$ * $2$ = $3$ $4$
#                  $1$ = valeur d'une tranche
#                  $2$ = nombre de tranches
#                  $3$ = montant
#                  $4$ = devise du tarif
#                  $5$ = rÃ©gion (tag non utilisÃ© actuellement dans message)

      FORMATV=FORMAT
      IDEC = len(num$(abs([F:CAP]ADL-fix([F:CAP]ADL))))-2
      If IDEC>[L]DECNBRBPT : FORMATV="N<:11."+num$(IDEC)+"#" : Endif
      LIBPROR1 = mess(19,185,1)
      Call DYNAMIC(LIBPROR1,"$1$",format$(FORMATV,[F:CAP]ADL)) From TEXTE
      Call DYNAMIC(LIBPROR1,"$2$",num$(NBTRANCHES)) From TEXTE
      Call DYNAMIC(LIBPROR1,"$3$",format$(FORMAT,arr([F:CAP]ADL*NBTRANCHES,[L]CURRNDBPT))) From TEXTE
      Call DYNAMIC(LIBPROR1,"$4$",[L]CURBPT) From TEXTE
      Call DYNAMIC(LIBPROR1,"$5$",[L]BPTARE) From TEXTE

      If WGROWEI-[F:CAP]MINQTY = [F:CAP]BKT*NBTRANCHES : # pas d'arrondi nombre de tranches

        If [F:CAP]MINQTY = 0                           : # pas de borne infÃ©rieure

#                    (poids retenu $1$ $2$ soit $3$ tranches de $4$ $2$)
#                      $1$ = poids
#                      $2$ = unitÃ© de poids du tarif
#                      $3$ = nombre de tranches
#                      $4$ = poids d'une tranche

          LIBPROR2="   "+mess(21,185,1)
          Call DYNAMIC(LIBPROR2,"$1$",num$(WGROWEI)) From TEXTE
          Call DYNAMIC(LIBPROR2,"$2$",[F:BPT]WEU) From TEXTE
          Call DYNAMIC(LIBPROR2,"$3$",num$(NBTRANCHES)) From TEXTE
          Call DYNAMIC(LIBPROR2,"$4$",num$([F:CAP]BKT)) From TEXTE

        Else                                           : # il y a une borne infÃ©rieure

#                    (poids retenu: $1$ - $2$ = $3$ $4$ soit $5$ tranches de $6$ $4$)
#                      $1$ = poids
#                      $2$ = borne infÃ©rieure de poids (borne comprise)
#                      $3$ = poids calculÃ©
#                      $4$ = unitÃ© de poids du tarif
#                      $5$ = nombre de tranches
#                      $6$ = poids d'une tranche

          LIBPROR2="   "+mess(20,185,1)
          Call DYNAMIC(LIBPROR2,"$1$",num$(WGROWEI)) From TEXTE
          Call DYNAMIC(LIBPROR2,"$2$",num$([F:CAP]MINQTY)) From TEXTE
          Call DYNAMIC(LIBPROR2,"$3$",num$(WGROWEI-[F:CAP]MINQTY)) From TEXTE
          Call DYNAMIC(LIBPROR2,"$4$",[F:BPT]WEU) From TEXTE
          Call DYNAMIC(LIBPROR2,"$5$",num$(NBTRANCHES)) From TEXTE
          Call DYNAMIC(LIBPROR2,"$6$",num$([F:CAP]BKT)) From TEXTE

        Endif

      Else                                             : # arrondi nombre de tranches

        If [F:CAP]MINQTY = 0                           : # pas de borne infÃ©rieure

#                (poids retenu: $1$ $2$ arrondi Ã  la $3$ de $4$ $2$ soit $5$ tranches)
#                  $1$ = poids
#                  $2$ = unitÃ© de poids du tarif
#                  $3$ = type d'arrondi: menu local 238 (1=tranche< 2=tranche> 3=tranche la +proche)
#                  $4$ = poids d'une tranche
#                  $5$ = nombre de tranches

          LIBPROR2="   "+mess(23,185,1)
          Call DYNAMIC(LIBPROR2,"$1$",num$(WGROWEI)) From TEXTE
          Call DYNAMIC(LIBPROR2,"$2$",[F:BPT]WEU) From TEXTE
          Call DYNAMIC(LIBPROR2,"$3$",mess([F:CAP]WEIRND,238,1)) From TEXTE
          Call DYNAMIC(LIBPROR2,"$4$",num$([F:CAP]BKT)) From TEXTE
          Call DYNAMIC(LIBPROR2,"$5$",num$(NBTRANCHES)) From TEXTE

        Else                                           : # il y a une borne infÃ©rieure

#                (poids retenu: $1$ - $2$ = $3$ $4$ arrondi Ã  la $5$ de $6$ $4$ soit $7$ tranches)
#                  $1$ = poids
#                  $2$ = borne infÃ©rieure de poids (borne comprise)
#                  $3$ = poids calculÃ©
#                  $4$ = unitÃ© de poids du tarif
#                  $5$ = type d'arrondi: menu local 238 (1=tranche< 2=tranche> 3=tranche la +proche)
#                  $6$ = poids d'une tranche
#                  $7$ = nombre de tranches

          LIBPROR2="   "+mess(22,185,1)
          Call DYNAMIC(LIBPROR2,"$1$",num$(WGROWEI)) From TEXTE
          Call DYNAMIC(LIBPROR2,"$2$",num$([F:CAP]MINQTY)) From TEXTE
          Call DYNAMIC(LIBPROR2,"$3$",num$(WGROWEI-[F:CAP]MINQTY)) From TEXTE
          Call DYNAMIC(LIBPROR2,"$4$",[F:BPT]WEU) From TEXTE
          Call DYNAMIC(LIBPROR2,"$5$",mess([F:CAP]WEIRND,238,1)) From TEXTE
          Call DYNAMIC(LIBPROR2,"$6$",num$([F:CAP]BKT)) From TEXTE
          Call DYNAMIC(LIBPROR2,"$7$",num$(NBTRANCHES)) From TEXTE

        Endif
      Endif
    Endif
  Endif
Endif
Filter [CAP]

#--- montant proportionnel

If [F:BPT]BKT<>0 & [F:BPT]ADL<>0
  NBTRANCHES=POIDS_CPP/[F:BPT]BKT
#   arrondi : 1=tranche < / 2=tranche > / 3=tranche la + proche
  Case [F:BPT]WEIRND
    When 1       : NBTRANCHES=int(NBTRANCHES)
    When 2       : NBTRANCHES=int(NBTRANCHES+0.999999)
    When Default : NBTRANCHES=arr(NBTRANCHES,1)
  Endcase
  AMTFRE += arr([F:BPT]ADL*NBTRANCHES,[L]CURRNDBPT)

    If [F:BPT]ADL*NBTRANCHES <>0

#                Montant proportionnel de $1$ * $2$ = $3$ $4$
#                  $1$ = valeur d'une tranche
#                  $2$ = nombre de tranches
#                  $3$ = montant
#                  $4$ = devise du tarif

      FORMATV=FORMAT
      IDEC= len(num$(abs([F:BPT]ADL-fix([F:BPT]ADL))))-2
      If IDEC>[L]DECNBRBPT : FORMATV="N<:11."+num$(IDEC)+"#" : Endif
      LIBPRO1 = mess(18,185,1)
      Call DYNAMIC(LIBPRO1,"$1$",format$(FORMATV,[F:BPT]ADL)) From TEXTE
      Call DYNAMIC(LIBPRO1,"$2$",num$(NBTRANCHES)) From TEXTE
      Call DYNAMIC(LIBPRO1,"$3$",format$(FORMAT,arr([F:BPT]ADL*NBTRANCHES,[L]CURRNDBPT))) From TEXTE
      Call DYNAMIC(LIBPRO1,"$4$",CURBPT) From TEXTE

      If WGROWEI - [F:CAP]MINQTY = [F:BPT]BKT*NBTRANCHES : # pas d'arrondi nombre de tranches

        If [F:CAP]MINQTY = 0                             : # pas de borne infÃ©rieure

#                    (poids retenu $1$ $2$ soit $3$ tranches de $4$ $2$)
#                      $1$ = poids
#                      $2$ = unitÃ© de poids du tarif
#                      $3$ = nombre de tranches
#                      $4$ = poids d'une tranche

          LIBPRO2="   "+mess(21,185,1)
          Call DYNAMIC(LIBPRO2,"$1$",num$(WGROWEI)) From TEXTE
          Call DYNAMIC(LIBPRO2,"$2$",[F:BPT]WEU) From TEXTE
          Call DYNAMIC(LIBPRO2,"$3$",num$(NBTRANCHES)) From TEXTE
          Call DYNAMIC(LIBPRO2,"$4$",num$([F:BPT]BKT)) From TEXTE

        Else                                             : # il  y a une borne infÃ©rieure

#                    (poids retenu: $1$ - $2$ = $3$ $4$ soit $5$ tranches de $6$ $4$)
#                      $1$ = poids
#                      $2$ = borne infÃ©rieure de poids (borne comprise)
#                      $3$ = poids calculÃ©
#                      $4$ = unitÃ© de poids du tarif
#                      $5$ = nombre de tranches
#                      $6$ = poids d'une tranche

          LIBPRO2="   "+mess(20,185,1)
          Call DYNAMIC(LIBPRO2,"$1$",num$(WGROWEI)) From TEXTE
          Call DYNAMIC(LIBPRO2,"$2$",num$([F:CAP]MINQTY)) From TEXTE
          Call DYNAMIC(LIBPRO2,"$3$",num$(WGROWEI-[F:CAP]MINQTY)) From TEXTE
          Call DYNAMIC(LIBPRO2,"$4$",[F:BPT]WEU) From TEXTE
          Call DYNAMIC(LIBPRO2,"$5$",num$(NBTRANCHES)) From TEXTE
          Call DYNAMIC(LIBPRO2,"$6$",num$([F:BPT]BKT)) From TEXTE

        Endif

      Else                                               : # arrondi nombre de tranches

        If [F:CAP]MINQTY = 0                             : # pas de borne infÃ©rieure

#                (poids retenu: $1$ $2$ arrondi Ã  la $3$ de $4$ $2$ soit $5$ tranches)
#                  $1$ = poids
#                  $2$ = unitÃ© de poids du tarif
#                  $3$ = type d'arrondi: menu local 238 (1=tranche< 2=tranche> 3=tranche la +proche)
#                  $4$ = poids d'une tranche
#                  $5$ = nombre de tranches

          LIBPRO2="   "+mess(23,185,1)
          Call DYNAMIC(LIBPRO2,"$1$",num$(WGROWEI)) From TEXTE
          Call DYNAMIC(LIBPRO2,"$2$",[F:BPT]WEU) From TEXTE
          Call DYNAMIC(LIBPRO2,"$3$",mess([F:BPT]WEIRND,238,1)) From TEXTE
          Call DYNAMIC(LIBPRO2,"$4$",num$([F:BPT]BKT)) From TEXTE
          Call DYNAMIC(LIBPRO2,"$5$",num$(NBTRANCHES)) From TEXTE

        Else                                           : # il y a une borne infÃ©rieure

#              (poids retenu: $1$ - $2$ = $3$ $4$ arrondi Ã  la $5$ de $6$ $4$ soit $7$ tranches)
#                $1$ = poids
#                $2$ = borne infÃ©rieure de poids (borne comprise)
#                $3$ = poids calculÃ©
#                $4$ = unitÃ© de poids du tarif
#                $5$ = type d'arrondi: menu local 238 (1=tranche< 2=tranche> 3=tranche la +proche)
#                $6$ = poids d'une tranche
#                $7$ = nombre de tranches

          LIBPRO2="   "+mess(22,185,1)
          Call DYNAMIC(LIBPRO2,"$1$",num$(WGROWEI)) From TEXTE
          Call DYNAMIC(LIBPRO2,"$2$",num$([F:CAP]MINQTY)) From TEXTE
          Call DYNAMIC(LIBPRO2,"$3$",num$(WGROWEI-[F:CAP]MINQTY)) From TEXTE
          Call DYNAMIC(LIBPRO2,"$4$",[F:BPT]WEU) From TEXTE
          Call DYNAMIC(LIBPRO2,"$5$",mess([F:BPT]WEIRND,238,1)) From TEXTE
          Call DYNAMIC(LIBPRO2,"$6$",num$([F:BPT]BKT)) From TEXTE
          Call DYNAMIC(LIBPRO2,"$7$",num$(NBTRANCHES)) From TEXTE

        Endif

      Endif

    Endif
Endif

#--- si devises diffÃ©rentes
If [L]CUR<>[L]CURBPT
  LIBCONVD = "   "+mess(69,116,1)+" = "+format$(FORMAT,AMTFRE)-[L]CURBPT
  If WCHGTYP=0          : WCHGTYP=1     : Endif
  If WCHGDAT=[00/00/00] : WCHGDAT=date$ : Endif
  Call CONVERT([L]CURBPT,[L]CUR,GLOCALDEV,WCHGTYP,WCHGDAT,AMTFRE,AMTFRE,GBIDI3) From TRTDEV
Endif

#--- trace

Case STAT
  When 1       : FRELIB(0)=mess(49,125,1)-mess(3,14,1)-num$([M]VBPTNUM)
  When 2       : FRELIB(0)=mess(49,125,1)-mess(129,198,1)-num$([M]VBPTNUM)
  When 3       : FRELIB(0)=mess(11,15,1)-num$([M]VBPTNUM)-mess(1,8,1)
  When 4       : FRELIB(0)=mess(81,200,1)
  When 5       : FRELIB(0)=mess(159,196,1)
  When Default : Gosub EXPLICATION   : # explication du calcul
Endcase

End

#######################
#  explication du calcul.
$EXPLICATION
Raz FRELIB, ILIB
If LIBNCAL<>""  & dim(FRELIB)>ILIB : FRELIB(ILIB)=LIBNCAL   : ILIB+=1 : Endif
If LIBCONPV<>"" & dim(FRELIB)>ILIB : FRELIB(ILIB)=LIBCONPV  : ILIB+=1 : Endif
If LIBFIX<>""   & dim(FRELIB)>ILIB : FRELIB(ILIB)=LIBFIX    : ILIB+=1 : Endif
If LIBFIXR<>""  & dim(FRELIB)>ILIB : FRELIB(ILIB)=LIBFIXR   : ILIB+=1 : Endif
If LIBPRO1<>""  & dim(FRELIB)>ILIB : FRELIB(ILIB)=LIBPRO1   : ILIB+=1 : Endif
If LIBPRO2<>""  & dim(FRELIB)>ILIB : FRELIB(ILIB)=LIBPRO2   : ILIB+=1 : Endif
If LIBPROR1<>"" & dim(FRELIB)>ILIB : FRELIB(ILIB)=LIBPROR1  : ILIB+=1 : Endif
If LIBPROR2<>"" & dim(FRELIB)>ILIB : FRELIB(ILIB)=LIBPROR2  : ILIB+=1 : Endif
For IJL=0 To dim(LIBUSER)-1
    If LIBUSER(IJL)<>"" & dim(FRELIB)>ILIB : FRELIB(ILIB)=LIBUSER(IJL) : ILIB+=1 : Endif
Next IJL
If LIBCONVD<>"" & dim(FRELIB)>ILIB : FRELIB(ILIB)=LIBCONVD  : ILIB+=1 : Endif

Return

#######################
#**
#* codifica caracteres
#*
#* @param PCHARIN   > cadena a limpiar
#*!
Funprog CODIFICA_CHR(PCHARIN)
#06.289.530 - JC.07012022.Error de memoria llena.ini
#Value     Clbfile  PCHARIN
#
#Local Clbfile PSTR(3) : PSTR=PCHARIN
Value     Char  PCHARIN

Local Char PSTR(250) : PSTR=PCHARIN
#06.289.530 - JC.07012022.Error de memoria llena.fin

  PSTR=func REPLACE(PSTR,"!","&#33;")  : PSTR=func REPLACE(PSTR,'"',"&#34;")  : PSTR=func REPLACE(PSTR,"#","&#35;")
  PSTR=func REPLACE(PSTR,"$","&#36;")  : PSTR=func REPLACE(PSTR,"%","&#37;")  : PSTR=func REPLACE(PSTR,"&","&#38;")
  PSTR=func REPLACE(PSTR,"'","&#39;")  : PSTR=func REPLACE(PSTR,"(","&#40;")  : PSTR=func REPLACE(PSTR,")","&#41;")
  PSTR=func REPLACE(PSTR,"*","&#42;")  : PSTR=func REPLACE(PSTR,"+","&#43;")  : PSTR=func REPLACE(PSTR,",","&#44;")
  PSTR=func REPLACE(PSTR,"-","&#45;")  : PSTR=func REPLACE(PSTR,".","&#46;")  : PSTR=func REPLACE(PSTR,"/","&#47;")
  PSTR=func REPLACE(PSTR,":","&#58;")  : PSTR=func REPLACE(PSTR,"<","&#60;")  : PSTR=func REPLACE(PSTR,"=","&#61;")
  PSTR=func REPLACE(PSTR,">","&#62;")  : PSTR=func REPLACE(PSTR,"?","&#63;")  : PSTR=func REPLACE(PSTR,"@","&#64;")
  PSTR=func REPLACE(PSTR,"[","&#91;")  : PSTR=func REPLACE(PSTR,"\","&#92;")  : PSTR=func REPLACE(PSTR,"]","&#93;")
  PSTR=func REPLACE(PSTR,"^","&#94;")  : PSTR=func REPLACE(PSTR,"_","&#95;")  : PSTR=func REPLACE(PSTR,"`","&#96;")
  PSTR=func REPLACE(PSTR,"{","&#123;") : PSTR=func REPLACE(PSTR,"|","&#124;") : PSTR=func REPLACE(PSTR,"}","&#125;")
  PSTR=func REPLACE(PSTR,"~","&#126;") : #PSTR=func REPLACE(PSTR,";","&#59;")

End PSTR

#######################
# 06.288.121
#**
#* cálculo automático del código EAN
#*
#*!
Funprog CALC_EANCOD()
Local Integer   STAT,I,DC,WSUM,WNUM
Local Char      WEANCOD(20)

  # Código EANCOD
  Call NUMERO("ZEAN",GFCYDEF(9),datesyst,"",WEANCOD,STAT) From SUBANM
  If STAT = 0
    # Cálculo dígito control
    WSUM=0
    # (suma de los números en posición impar) * 1
    For I=1 To 12 Step 2
      WNUM=val(mid$(WEANCOD,I,1))
      WSUM+=(WNUM*1)
    Next I
    # (suma de los números en posición par) * 3
    For I=2 To 12 Step 2
      WNUM=val(mid$(WEANCOD,I,1))
      WSUM+=(WNUM*3)
    Next I
    # dc = 10 - resto(suma/10)
    DC = 10-(mod(WSUM,10))
    If DC >= 10 : DC=0 : Endif

    # EANCOD = EAN + DC
    WEANCOD += num$(DC)
  Else
     GOK=0
  Endif

End WEANCOD
