#<AdxTL>@(#)0.0.0.0 $Revision$ 
# 06.298.127 - JC.10012021.Entregas con transportista distinto
# 06.298.712 - JC.11012021.Fecha expedición/entrega en las entregas
# 06.299.407 - JC.13012022.Error SOF por una cancelación
# 06.300.273 - JC.14012022.Error fichero SOF
# 06.299.138 - JC.12012022.Error importación STV - ajustes stock
# 06.304.506 - JC.26012022.Error importación SOF por cliente destinatario inactivo
# 06.308.480 - JC.02022022.Comandes certificats
# 06.309.060 - JC.07022022.Nº conformidad cooperativa
# 06.310.719 - JC.08022022.Condiciones de pago en entregas
# 06.314.358 - JC.14022022.Error importación SOF. Stock con estado A y Q
# 06.315.150 - JC.16022022.Error cuando hay una línea en fichero SOF que no existe en el VP
# 06.315.591 - JC.17022022.Error importación entrega cuando el detalle de línea en SOF es igual por detalle de línea Sage pero no suma lo mismo que el total de Sage
# 06.319.759 - JC.02032022.Facturas Canarias. Añadir Incoterm al generar la entrega
# 06.314.024 - JC.07032022.Adapación importación SOF para subcontratación
###########################################################################

#If GUSER="ADEV" Then
Call ZSGAENTSOF From ZSGAENTSOF
#Endif

End

##############################################################
Subprog ZSGAENTSOF

#Declaración de variables
Local Char WSGATMP(250), SGARECIBIDOS(250), WSGATRATADOS(250), CFILE(250), LNOMFICHERO(250), WFICHEROIMP(250), WLNEITEMCODE(250), WLNEDCSTATT05(250), WLNEQTYORDER(250)
Local Char WFICINP1(250), FICH2(250), RESULT(250), WCSTATT03(250)
Local Integer NFICHEROS, WNESTADO, NFICH2
Local Char FICHEROS(250)(1..1000)
Local Char WESTADOS(20)(1..5)

Local Char FICHEROIMP(250), FICHEROEXP(250)

Local Integer A, LFSTATFICHERO, NFICHEROS, WTRAZA
Local Clbfile XDATA (15)

Global Integer GSTERROR,GERRSTOCK

If !clalev([F:ZFCY])  : Local File FACILITY   [ZFCY] : Endif
If !clalev([F:ZPRH])  : Local File STOPREH    [ZPRH] : Endif
If !clalev([F:ZPRE])  : Local File STOPRED    [ZPRE] : Endif
If !clalev([F:ZBPC])  : Local File BPCUSTOMER [ZBPC] : Endif
If !clalev([F:ZITM])  : Local File ITMMASTER  [ZITM] : Endif
If !clalev([F:ITV])   : Local File ITMMVT     [ITV] : Endif
If !clalev([F:ZBPD])  : Local File BPDLVCUST  [ZBPD] : Endif                                  # 06.304.506.new

  WFICHEROIMP='SOF0*'
#  WFICHEROIMP='aaaSOF123'
#  WFICHEROIMP='SOF0120220211165012000'
#  WFICHEROIMP='SOF0120220216161912000'
  Raz NFICHEROS

  WSGATMP       = "ZSGA\SGA\IMPORTX3"
  WSGARECIBIDOS = "ZSGA\SGA\SGA_to_ERP"
  WSGATRATADOS  = "ZSGA\SGA\SGA_to_ERP\processed\SOF"
  WSGAERROR     = "ZSGA\SGA\SGA_to_ERP\processed\ERR"

  WESTADOS(1)='Working'
  WESTADOS(2)='Release'
  WESTADOS(3)='Waiting'
  WESTADOS(4)='Paused'
  WESTADOS(5)='Closed'

  CFILE=filpath(WSGARECIBIDOS,WFICHEROIMP,'xml')
  ORDSYS = "dir "+CFILE+" /A-d /b"
  Call SYSTEME2 (adxmac(-1),ORDSYS,"",NFICHEROS,FICHEROS) From ORDSYS
  LFSTATFICHERO=0

  If instr(1,FICHEROS(1),'xml')=0
#    Call ECR_TRACE('No existe SOF0*',0) From GESECRAN
    End
  Endif

#  If !GSERVEUR
    Call OUVRE_TRACE ("Importación SOF")    From LECFIC
    Call ECR_TRACE("########################################################################",0) From GESECRAN
    WTRAZA=1
#  Endif

  # limpia la tabla
  If !clalev([F:AXX0]) Then : Local File ZEXPORTSOF [F:AXX0] : Endif
  Execsql From "5" Sql "Truncate table" - nomap + ".ZEXPORTSOF"
  Close Local File [AXX0]
  Call ECR_TRACE("Vacía la tabla temporal ZEXPORTSOF",0) From GESECRAN
  Call ECR_TRACE("########################################################################",0) From GESECRAN

  For A=1 To NFICHEROS
    LNOMFICHERO=mid$(FICHEROS(A),1,len(FICHEROS(A))-4)
    WFICINP1=LNOMFICHERO
    LNOMFICHERO=func ZAULIB01.REPLACE(LNOMFICHERO,'.xml','')
    Local Integer LERROR                                                    # 06.299.138.new

# 06.299.138.ini
    # control para aquellos ficheros que llegan desde el SGA con el nombre erróneo (STV0xxxxxxxxxxx.0.xml)
    If WFICINP1 <> LNOMFICHERO Then
      Call  LANZA_WORKFLOW_ERRORES(WFICINP1)
      Gosub MUEVE_FILE_ERR
      Break
    Endif
# 06.299.138.fin

    #Abrimos y leemos el fichero XML
    Openi filpath(WSGARECIBIDOS,WFICINP1,"xml") Using [ZZZ]
    Iomode adxifs  ""                           Using [ZZZ]
    Iomode adxirs  ""                           Using [ZZZ]
    Iomode adxium  50                           Using [ZZZ]
    Rdseq XDATA                                 Using [ZZZ]

    Call ECR_TRACE("Importación SOF, fichero "+LNOMFICHERO+".xml",0) From GESECRAN
    Call ECR_TRACE("########################################################################",0) From GESECRAN

    mkstat = 0 : fstat = 0 : GERRTRACE = 0

    Gosub GUARDA_SOF_EN_TABLA
    Openi Using [ZZZ]
    Local Integer LRDO
    Local Char LMSG(250)
    Call  COMPRUEBA_VP(LNOMFICHERO)
    Call  ELIMINA_LINEA_VP(LNOMFICHERO)
    LRDO = func COMPRUEBA_STOCK(LNOMFICHERO,LMSG)
    Call  VP_ENTREGABLE(LNOMFICHERO)
    Call  UNLOCK_OSTCTL(LNOMFICHERO)
    Call  UNLOCK_BPCSTA(LNOMFICHERO)                                                          # 06.304.506.new
    Call  GENERA_ENTREGA(LNOMFICHERO,WSGATMP,WFICINP1,WSGARECIBIDOS,WSGATRATADOS,WSGAERROR)
    Call  LOCK_OSTCTL(LNOMFICHERO)
    Call  LOCK_BPCSTA(LNOMFICHERO)                                                            # 06.304.506.new

    Gosub TRAZA_ERRORES_LINEAS

#    If WOK <> 0 Then                             # si se producen errores
#      Call  LANZA_WORKFLOW_ERRORES(LNOMFICHERO)
#      Gosub MUEVE_FILE_ERR
#    Else
#      Gosub MUEVE_FILE
#    Endif

#    Openi Using [ZECO]

  Next

  Call FERME_TRACE From LECFIC
  If !GSERVEUR Then
    Call LEC_TRACE From LECFIC
  Endif


  If dim(GSTERROR) > 0 Then : Kill GSTERROR   : Endif
  If dim(GERRSTOCK)> 0 Then : Kill GERRSTOCK  : Endif

End

##############################################################
$GUARDA_SOF_EN_TABLA

  Local Integer I,M,N,P,R,S,T,CONTROL1,CONTROL2,LCONTVALE,IANTES
  Local Integer WNVP, WNLIN
  Local Char    LSORCODE(250)
  Local Char    WSITE(250), WSORCODE(250), WSTATUS(250)
  Local Char    WPRPRELEASEDATE(250),WLNECSTATT20(250)
  Local Char    WPACNBR

  If !clalev([F:ZESOF]) Then : Local File ZEXPORTSOF [F:ZESOF] : Endif
  If !clalev([F:ZPRE0]) Then : Local File STOPRED    [F:ZPRE0] : Endif
  If !clalev([F:ZPRH0]) Then : Local File STOPREH    [F:ZPRH0] : Endif                        # 06.314.024.new

  # calcula el número de vales que hay dentro del fichero SOF
  # para ejecutar el proceso de lectura de vales, sólamente, tantas veces como vales de preparación contenga el fichero SOF
  P=I
  While 1=1
    Raz LSORCODE
    P=P+10
    LSORCODE  = func GET_PROPXML(XDATA,"SorCode",P)
    If LSORCODE <> "" Then
      WNVP+=1
    Else
      Break
    Endif
    If WNVP>999
      Break
    Endif
  Wend

  I         = 1
  LCONTVALE = 1

#CABECERAS #######################################################
  For R=1 To WNVP
    If LCONTVALE > WNVP Then
      Break
    Else
      WSITE           = func GET_PROPXML(XDATA,"Site",I)
      WSORCODE        = func GET_PROPXML(XDATA,"SorCode",I)
      WSTATUS         = func GET_PROPXML(XDATA,"Status",I)
# 06.299.407.ini
      If WSTATUS = "Cancelled" Then : Goto ENDFOR : Endif
# 06.299.407.fin
      WPACNBR         = func GET_PROPXML(XDATA,"PrpContainers",I)
      WPRPRELEASEDATE = func GET_PROPXML(XDATA,"PrpReleaseDate",I)
      IANTES         = I
      WCSTATT03      = func ZSGAENTSOF.GET_PROPXML(XDATA,"CstAtt03",I)
      I              = IANTES
      Trbegin [ZESOF]
      Raz [F:ZESOF]
      Local Integer WLONG
      Read [F:ZPRH0]PRH0 = WSORCODE                                                           # 06.314.024.new
     #NOMFICH
      [F:ZESOF]NOMFICH = LNOMFICHERO
     #H
      WLONG   = 1
      RESULT  ='H'
      RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
      [F:ZESOF]INDICADOR = RESULT
     #SALFCY
      WLONG   = 5
      RESULT  ='PHISP'
      RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
      [F:ZESOF]SALFCY = RESULT
     #STOFCY
      WLONG   = 5
      RESULT  ='PHISP'
      RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
      [F:ZESOF]STOFCY = RESULT
     #SDHNUM
      WLONG   = 10
      RESULT  = WCSTATT03
      RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
      RESULT  = vireblc(RESULT,2)
      [F:ZESOF]SDHNUM = RESULT
     #SDHTYP
      WLONG   = 2
      RESULT  = 'EN'
      If [F:ZPRH0]ORIPRH = 3 Then : RESULT = 'ES' : Endif                                     # 06.314.024.new
      RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
      [F:ZESOF]SDHTYP = RESULT
     #BPCORD
      Read [ZPRH]PRH0=WSORCODE
      If fstat
      Endif
      WLONG   = 50
      RESULT  = [ZPRH]BPCORD
      RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
      RESULT  = vireblc(RESULT,1)
      [F:ZESOF]BPCORD = RESULT
     #OSTCTL
      Read [ZBPC]BPC0 = [ZPRH]BPCORD
      If !fstat Then
        [F:ZESOF]OSTCTL = [F:ZBPC]OSTCTL
      Endif
# 06.304.506.ini
     #BPCSTA
      Read [ZBPD]BPD0 = [ZPRH]BPCORD;[ZPRH]BPAADD
      If !fstat Then
        [F:ZESOF]BPCSTA = [F:ZBPD]ENAFLG
      Endif
# 06.304.506.fin
     #BPAADD
      WLONG   = 3
      RESULT  = [ZPRH]BPAADD
      RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
      RESULT  = vireblc(RESULT,1)
      [F:ZESOF]BPAADD = RESULT
     #CUR
      WLONG   = 3
      RESULT  = 'EUR'
      RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
      RESULT  = vireblc(RESULT,1)
      [F:ZESOF]CUR = RESULT
     #PACNBR
      WLONG   = 1
      RESULT  = WPACNBR
      RESULT  = vireblc(RESULT,1)
      [F:ZESOF]PACNBR = RESULT
# 06.298.712.ini
#     #SHIDAT
#      WLONG=10
#      [F:ZESOF]SHIDAT = gdat$(val(mid$(WPRPRELEASEDATE,9,2)),val(mid$(WPRPRELEASEDATE,6,2)),val(mid$(WPRPRELEASEDATE,1,4)))
#     #DLVDAT
#      [F:ZESOF]DLVDAT = gdat$(val(mid$(WPRPRELEASEDATE,9,2)),val(mid$(WPRPRELEASEDATE,6,2)),val(mid$(WPRPRELEASEDATE,1,4)))
     #SHIDAT
      WLONG=10
      [F:ZESOF]SHIDAT = mid$(LNOMFICHERO,6,8)
     #DLVDAT
      [F:ZESOF]DLVDAT = mid$(LNOMFICHERO,6,8)
# 06.298.712.fin
     #ZTIPOPEDSGA
      WLONG   = 20
      IANTES = I
      CSTATT20= func ZSGAENTSOF.GET_PROPXML(XDATA,"CstAtt20",I)
      I       = IANTES
      RESULT  = CSTATT20
      RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
      RESULT  = vireblc(RESULT,1)
      [F:ZESOF]ZTIPOPEDSGA = RESULT
     #PRHNUM
      [F:ZESOF]PRHNUM = WSORCODE
     #ZSTATUS
      [F:ZESOF]STA    = WSTATUS
     #PRELIN
      [F:ZESOF]PRELIN = 0
     #ZGENSDHFLG
      [F:ZESOF]ZGENSDHFLG = 2
      Write [F:ZESOF]
      If !fstat Then
        Commit
        Call ECR_TRACE("Guarda en tabla el VP:"-WSORCODE,0) From GESECRAN
        Call ECR_TRACE("---------------------------------------",0) From GESECRAN
        GSTERROR = 0
      Else
        Rollback
        Call ECR_TRACE("Error al guardar en tabla el VP:"-WSORCODE,0) From GESECRAN
        Call ECR_TRACE("---------------------------------------",1) From GESECRAN
        GSTERROR = 1
      Endif

#LINEAS #######################################################
      # calcula el número de líneas
      CONTROL1 = I
      Raz WNLIN
      While 1=1
        WLNENUMBER    = ""
        WLNENUMBER    = func GET_PROPXML(XDATA,"LneNumber",CONTROL1)
        If val(WLNENUMBER)<>0
          CONTROL2    = I
          WLNENUMBER  = func GET_PROPXML(XDATA,"SorCode",CONTROL2)
          If (CONTROL1 < CONTROL2) or (CONTROL1 > CONTROL2 and CONTROL2 = 0) Then
            WNLIN     +=1
          Else
            Break
          Endif
        Else
          If WLNENUMBER=''
            Break
          Endif
        Endif
        If WNLIN>999
          Break
        Endif
      Wend

      For N=1 To WNLIN
        S = I
        T = I
        WCONTROLSORCODE       = func GET_PROPXML(XDATA,"SorCode",S)
        WCONTROLLNEDITEMCODE  = func GET_PROPXML(XDATA,"LneDItemCode",T)
        If S < T and S <> 0 and T <> 0 Then
          Goto ENDNEXTLINEA
        Elsif S = 0 and T = 0 Then
          Goto ENDNEXTVALE
        Endif

        WLNENUMBER    = func GET_PROPXML(XDATA,"LneNumber",I)
        WLNENUMBER    = toupper(ctrans(left$(WLNENUMBER+space$(WLONG),WLONG)))
        WLNENUMBER    = vireblc(WLNENUMBER,1)

        WLONG         = 15
        WLNECSTATT20  = func GET_PROPXML(XDATA,"LneCstAtt20",I)
        WLNECSTATT20  = toupper(ctrans(left$(WLNECSTATT20+space$(WLONG),WLONG)))
        WLNECSTATT20  = vireblc(WLNECSTATT20,1)

#LINEAS DETALLE #######################################################
        # número de líneas detalle
        Local Integer J,K,L,WNLINDETAIL
        Local Char    WLNENUMBERDETAIL(10),LTEMP1(50)
        L = I
        While 1=1
          WLNENUMBERDETAIL  = ""
          WLNENUMBERDETAIL  = func GET_PROPXML(XDATA,"LneDItemCode",L)
          If WLNENUMBERDETAIL <> ""
            WNLINDETAIL+=1
          Else
            Break
          Endif
          If WNLINDETAIL>999
            Break
          Endif
          If WLNENUMBERDETAIL <> "" Then : J = L : K = J : Endif
          LTEMP1 =  func GET_PROPXML(XDATA,"LneDItemCode",J)
          LTEMP1 =  func GET_PROPXML(XDATA,"LneNumber",K)
          If J > K and K <> 0 Then
            L=J
            Break
          Endif
        Wend

        For M=1 To WNLINDETAIL
          Raz CONTROL1, CONTROL2
          Trbegin [F:ZESOF]
          Raz [F:ZESOF]
         #NOMFICH
          [F:ZESOF]NOMFICH = LNOMFICHERO
         #L
          WLONG   = 1
          RESULT  = 'L'
          RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
          RESULT  = vireblc(RESULT,1)
          [F:ZESOF]INDICADOR = RESULT
         #STOFCY
          WLONG   = 5
          RESULT  ='PHISP'
          RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
          [F:ZESOF]STOFCY = RESULT
         #SDHNUM
          WLONG   = 10
          RESULT  = WCSTATT03
          RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
          RESULT  = vireblc(RESULT,2)
          [F:ZESOF]SDHNUM = RESULT
         #SDHTYP
          WLONG   = 2
          RESULT  = 'EN'
          If [F:ZPRH0]ORIPRH = 3 Then : RESULT = 'ES' : Endif                                 # 06.314.024.new
          RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
          [F:ZESOF]SDHTYP = RESULT
         #PRHNUM
          [F:ZESOF]PRHNUM = WSORCODE
         #PRELIN
          WLONG   = 10
          [F:ZESOF]PRELIN = val(WLNENUMBER)
         #SOHNUM
          Read [F:ZPRE0]PRE0 = [F:ZESOF]PRHNUM;[F:ZESOF]PRELIN
          [F:ZESOF]SOHNUM = [F:ZPRE0]ORINUM
         #SOPLIN
          [F:ZESOF]SOPLIN = [F:ZPRE0]ORILIN
         #ZUSRSERV
          [F:ZESOF]ZUSRSERV = WLNECSTATT20
         #ITMREF
          WLONG   = 250
          RESULT  = func GET_PROPXML(XDATA,"LneDItemCode",I)
          RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
          RESULT  = vireblc(RESULT,1)
          [F:ZESOF]ITMREF = RESULT
         #ITMDES
          WLONG   = 250
          Read [F:ZITM]ITM0=RESULT
          RESULT  = [ZITM]ITMDES2
          RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
          RESULT  = vireblc(RESULT,1)
          [F:ZESOF]ITMDES = RESULT
         #ZCODBULTO
          WLONG   = 18
          RESULT  = func GET_PROPXML(XDATA,"LneDClientContCode",I)
          RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
          RESULT  = vireblc(RESULT,1)
          [F:ZESOF]ZCODBULTO = RESULT
         #QTYU
          WLONG   = 250
          WLNEQTYORDER  = func GET_PROPXML(XDATA,"LneDQtyShipped",I)
          RESULT  = WLNEQTYORDER
          Read [F:ITV]ITV0=WLNEITEMCODE;'PHISP'
          RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
          RESULT  = vireblc(RESULT,1)
          [F:ZESOF]QTY = val(RESULT)
         #SAU
          WLONG   = 250
          WLNEQTYUOMCODE  = func GET_PROPXML(XDATA,"LneDQtyUoMCode",I)
          RESULT  = WLNEQTYUOMCODE
          RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
          RESULT  = vireblc(RESULT,1)
          [F:ZESOF]SAU = RESULT
          WLONG     = 250
          CONTROL1  = I
          CONTROL2  = I
          RESULT    = func GET_PROPXML(XDATA,"LneDCstAtt01",CONTROL1)
          RESULT    = func GET_PROPXML(XDATA,"LneDItemCode",CONTROL2)
          If CONTROL1 = 0 and CONTROL2 = 0 Then
            Goto ENDZLOTPROV
          # existe BPSLOT para esa línea de detalle
          Elsif ((CONTROL1 < CONTROL2) and CONTROL1 <> 0) or CONTROL2 = 0 Then
            RESULT  = func GET_PROPXML(XDATA,"LneDCstAtt01",I)
            RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
            RESULT  = vireblc(RESULT,1)
            [F:ZESOF]ZLOTPROV = RESULT
          # existe BPSLOT pero en otra línea del vale de preparación
          Else
            CONTROL1  = I
            CONTROL2  = I
            RESULT    = func GET_PROPXML(XDATA,"LneDCstAtt01",CONTROL1)
            RESULT    = func GET_PROPXML(XDATA,"LneNumber",CONTROL2)
            If (CONTROL1 < CONTROL2) and (CONTROL1 <> 0) and (CONTROL2 = 0) Then
              RESULT  = func GET_PROPXML(XDATA,"LneDCstAtt01",I)
              RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
              RESULT  = vireblc(RESULT,1)
              [F:ZESOF]ZLOTPROV = RESULT
            Endif
          Endif
          $ENDZLOTPROV
         #LOT
          WLONG     = 250
          CONTROL1  = I
          CONTROL2  = I
          RESULT    = func GET_PROPXML(XDATA,"LneDCstAtt05",CONTROL1)
          RESULT    = func GET_PROPXML(XDATA,"LneDItemCode",CONTROL2)
          # existe LOT para esa línea de detalle
          If CONTROL1 = 0 and CONTROL2 = 0 Then
            Goto ENDLOT
          Elsif ((CONTROL1 < CONTROL2) and CONTROL1 <> 0) or CONTROL2 = 0 Then
            RESULT  = func GET_PROPXML(XDATA,"LneDCstAtt05",I)
            RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
            RESULT  = vireblc(RESULT,1)
            [F:ZESOF]LOT = RESULT
          # existe LOT pero en otra línea del vale de preparación
          Else
            CONTROL1  = I
            CONTROL2  = I
            RESULT    = func GET_PROPXML(XDATA,"LneDCstAtt05",CONTROL1)
            RESULT    = func GET_PROPXML(XDATA,"LneNumber",CONTROL2)
            If (CONTROL1 < CONTROL2) and (CONTROL1 <> 0) and (CONTROL2 = 0) Then
              RESULT  = func GET_PROPXML(XDATA,"LneDCstAtt05",I)
              RESULT  = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
              RESULT  = vireblc(RESULT,1)
              [F:ZESOF]LOT = RESULT
            Endif
          Endif
          $ENDLOT
         #ZGENSDHFLG
          [F:ZESOF]ZGENSDHFLG = 2
          Write [F:ZESOF]
          If !fstat Then
            Commit
            GSTERROR = 0
          Else
            Rollback
            Call ECR_TRACE("Error en línea:"-num$(WLNENUMBER),1) From GESECRAN
            GSTERROR = 1
          Endif
        Next M  # detail
      Next N    # línea
      $ENDNEXTLINEA
      LCONTVALE+=1
    Endif
# 06.299.407.ini
    $ENDFOR
# 06.299.407.fin
  Next R        # vale
  Call ECR_TRACE("########################################################################",0) From GESECRAN

  $ENDNEXTVALE

  Close Local File [ZESOF],[ZPRE0]

  If dim(I)                 > 0 Then : Kill I                 : Endif
  If dim(J)                 > 0 Then : Kill J                 : Endif
  If dim(K)                 > 0 Then : Kill K                 : Endif
  If dim(L)                 > 0 Then : Kill L                 : Endif
  If dim(M)                 > 0 Then : Kill M                 : Endif
  If dim(N)                 > 0 Then : Kill N                 : Endif
  If dim(P)                 > 0 Then : Kill P                 : Endif
  If dim(R)                 > 0 Then : Kill R                 : Endif
  If dim(S)                 > 0 Then : Kill S                 : Endif
  If dim(T)                 > 0 Then : Kill T                 : Endif
  If dim(CONTROL1)          > 0 Then : Kill CONTROL1          : Endif
  If dim(CONTROL2)          > 0 Then : Kill CONTROL2          : Endif
  If dim(LCONTVALE)         > 0 Then : Kill LCONTVALE         : Endif
  If dim(LSORCODE)          > 0 Then : Kill LSORCODE          : Endif
  If dim(LTEMP1)            > 0 Then : Kill LTEMP1            : Endif
  If dim(WLNENUMBER)        > 0 Then : Kill WLNENUMBER        : Endif
  If dim(WNLIN)             > 0 Then : Kill WNLIN             : Endif
  If dim(WNLINDETAIL)       > 0 Then : Kill WNLINDETAIL       : Endif
  If dim(WLNENUMBERDETAIL)  > 0 Then : Kill WLNENUMBERDETAIL  : Endif
  If dim(WNVP)              > 0 Then : Kill WNVP              : Endif
  If dim(WPRPCONTAINERS)    > 0 Then : Kill WPRPCONTAINERS    : Endif
  If dim(WSITE)             > 0 Then : Kill WSITE             : Endif
  If dim(WSORCODE)          > 0 Then : Kill WSORCODE          : Endif
  If dim(WTRNROUTECODE)     > 0 Then : Kill WTRNROUTECODE     : Endif
  If dim(WTRNROUTESTOPS)    > 0 Then : Kill WTRNROUTESTOPS    : Endif

Return

###############################################################
#**
#* comprueba si existen las líneas de VP que han llegado en el fichero SOF en Sage
#*
#* @param PNOMFICH  > nombre del fichero SOF
#*!
Subprog COMPRUEBA_VP(PNOMFICH)
Value Char PNOMFICH

  If !clalev([F:AXX1]) Then : Local File ZEXPORTSOF [F:AXX1] : Endif
  If !clalev([F:AXX2]) Then : Local File ZEXPORTSOF [F:AXX2] : Endif
  If !clalev([F:AXX3]) Then : Local File STOPRED    [F:AXX3] : Endif
  Filter [F:AXX1] Where INDICADOR = "L"
  For [AXX1]
    Read [F:AXX3]PRE0 = [F:AXX1]PRHNUM;[F:AXX1]PRELIN
    # si la línea del VP no existe en Sage, marca todos los VPs que van a la misma entrega como no entregables
    If fstat Then
      Filter [F:AXX2] Where SDHNUM = [F:AXX1]SDHNUM and PRHNUM = [F:AXX1]PRHNUM and PRELIN = [F:AXX1]PRELIN
      For [F:AXX2]
        [F:AXX2]ZGENSDHFLG = 1
        [F:AXX2]ZMSGERROR  = "La línea no existe en Sage"
# 06.315.150.ini
        GERRSTOCK = 1
        Call ECR_TRACE("No existe la línea:"-num$([F:AXX1]PRELIN)-"del VP"-[F:AXX1]PRHNUM,1) From GESECRAN
# 06.315.150.fin
        Trbegin [F:AXX2]
        Rewrite [F:AXX2]
        If !fstat Then
          Commit
        Else
          Rollback
        Endif
      Next
      Filter [F:AXX2]
      Filter [F:AXX2] Where SDHNUM = [F:AXX1]SDHNUM
      For [F:AXX2]
        [F:AXX2]ZGENSDHFLG = 1
        Trbegin [F:AXX2]
        Rewrite [F:AXX2]
        If !fstat Then
          Commit
        Else
          Rollback
        Endif
      Next
      Filter [F:AXX2]
    Else
      # sí que existe la línea del VP pero el artículo ni la unidad coinciden, marca todos los VPs que van a la misma entrega como no entregables
      If [F:AXX3]ITMREF <> [F:AXX1]ITMREF or [F:AXX3]STU <> [F:AXX1]SAU Then
        Filter [F:AXX2] Where SDHNUM = [F:AXX1]SDHNUM and PRHNUM = [F:AXX1]PRHNUM and PRELIN = [F:AXX1]PRELIN
        For [F:AXX2]
          [F:AXX2]ZGENSDHFLG = 1
          [F:AXX2]ZMSGERROR  = "El artículo o las unidades de la línea no coincide en Sage"
# 06.315.150.ini
          GERRSTOCK = 1
          Call ECR_TRACE("El artículo o las unidades de la línea:"-num$([F:AXX1]PRELIN)-"del VP"-[F:AXX1]PRHNUM-"no coincide en Sage",1) From GESECRAN
# 06.315.150.fin
          Trbegin [F:AXX2]
          Rewrite [F:AXX2]
          If !fstat Then
            Commit
          Else
            Rollback
          Endif
        Next
        Filter [F:AXX2]
        Filter [F:AXX2] Where SDHNUM = [F:AXX1]SDHNUM
        For [F:AXX2]
          [F:AXX2]ZGENSDHFLG = 1
          Trbegin [F:AXX2]
          Rewrite [F:AXX2]
          If !fstat Then
            Commit
          Else
            Rollback
          Endif
        Next
        Filter [F:AXX2]
      Endif
    Endif
  Next
  Filter [F:AXX1]
  Close Local File [AXX1],[AXX2],[AXX3]

End

###############################################################
#**
#* cambia el estado de los vales a entregable
#*
#* @param PNOMFICH  > nombre del fichero SOF
#*!
Subprog VP_ENTREGABLE(PNOMFICH)
Value Char PNOMFICH

  Call ECR_TRACE("Actualiza vales a Entregables",0) From GESECRAN
  Call ECR_TRACE("---------------------------------------",0) From GESECRAN

  If !clalev([F:ZESO1]) Then : Local File ZVESOF1 [F:ZESO1] : Endif
  If !clalev([F:ZPRH])  Then : Local File STOPREH [F:ZPRH]  : Endif
  If !clalev([F:ZPRD])  Then : Local File STOPRED [F:ZPRD]  : Endif
  If !clalev([F:ZSOQ])  Then : Local File SORDERQ [F:ZSOQ]  : Endif
  Filter [F:ZESO1] Where NOMFICH = PNOMFICH and PRELIN <> 0 and ZGENSDHFLG = 2
  For [F:ZESO1]
    Read [F:ZPRH]PRH0 = [F:ZESO1]PRHNUM
    If !fstat Then
      Trbegin [F:ZPRH]
      [F:ZPRH]DLVFLG = 2
      Rewrite [F:ZPRH]
      If !fstat Then
        Commit
        GSTERROR = 0
      Else
        Rollback
        Call ECR_TRACE("Error al convertir el VP:"-[F:ZESO1]PRHNUM-"a entregable",1) From GESECRAN
        GSTERROR = 1
      Endif
    Else
      Call ECR_TRACE("No existe el VP:"-[F:ZESO1]PRHNUM,1) From GESECRAN
      GSTERROR = 1
    Endif
    Filter [F:ZPRD] Where PRHNUM = [F:ZESO1]PRHNUM and PRELIN = [F:ZESO1]PRELIN
    For [F:ZPRD]
      Read [F:ZSOQ]SOQ0 = [F:ZPRD]ORINUM;[F:ZPRD]ORILIN;[F:ZPRD]ORISEQ
      If !fstat Then
        [F:ZSOQ]OPRQTY    = 0
        [F:ZSOQ]OPRQTYSTU = 0
        [F:ZSOQ]PREQTY    = [F:ZESO1]QTY
        [F:ZSOQ]PREQTYSTU = [F:ZESO1]QTY
        Trbegin [F:ZSOQ]
        Rewrite [F:ZSOQ]
        If !fstat Then
          Commit
        Else
          Rollback
        Endif
      Endif
    Next
    Filter [F:ZPRD]
  Next

  Call ECR_TRACE("########################################################################",0) From GESECRAN

  Filter [F:ZESO1]
  Close Local File [ZESO1],[ZPRH],[ZPRD],[ZSOQ]

End

###############################################################
# muestra mensajes en la traza cuando se han producido errores en las líneas
# (no existen las líneas en Sage o artículo/unidades no coinciden)
$TRAZA_ERRORES_LINEAS
Local Char LSDHNUM(50)
  If !clalev([F:ZESO8]) Then : Local File ZVESOF8 [F:ZESO8] : Endif
  If !clalev([F:ZPRE])  Then : Local File STOPRED [F:ZPRE]  : Endif
  Filter [F:ZESO8] Where INDICADOR = "L" and ZGENSDHFLG <> 2
  For [ZESO8]
    If [F:ZESO8]SDHNUM <> LSDHNUM Then
      Call ECR_TRACE("No se gerena la entrega"-[F:ZESO8]SDHNUM-"por los siguientes motivos:",1) From GESECRAN
      LSDHNUM = [F:ZESO8]SDHNUM
    Endif
    Read [F:ZPRE]PRE0 = [F:ZESO8]PRHNUM;[F:ZESO8]PRELIN
    If fstat <> 0 Then
      Call ECR_TRACE([F:ZESO8]ZMSGERROR+". VP:"-[F:ZESO8]PRHNUM-"Línea:"-num$([F:ZESO8]PRELIN),1) From GESECRAN
    Else
      If [F:ZESO8]ITMREF <> [F:ZPRE]ITMREF or [F:ZESO8]SAU <> [F:ZPRE]STU Then
        Call ECR_TRACE([F:ZESO8]ZMSGERROR+". VP:"-[F:ZESO8]PRHNUM-"Línea:"-num$([F:ZESO8]PRELIN),1) From GESECRAN
      Endif
    Endif
  Next
  Call ECR_TRACE("########################################################################",0) From GESECRAN
  Filter [F:ZESO8]
  Close Local File [ZESO8],[ZPRE]
Return

###############################################################
#**
#* envía correo con la traza y el fichero que ha generado el error
#*
#* @param PNOMFICH  > nombre del fichero SOF
#*!
Subprog LANZA_WORKFLOW_ERRORES(PNOMFICH)
Value Char  PNOMFICH
  # lanza un workflow para avisar de que la importación ha fallado
  Global Char GCORREO(250),GFICHERO(250),GTEXTO1(250),GTEXTO2(250),GTEXTO3(250),GASUNTO(250)
  GASUNTO   = "Error en la importación SOF del fichero"-PNOMFICH
  GCORREO   = "sergi.cunill@hispanox.com"
  GCORREO   = "joseluis.chiva@auren.es"
  GFICHERO  = PNOMFICH
  GTEXTO1   = "Errores producidos en el tratamiento del fichero"-PNOMFICH+".xml"
  GTEXTO2   = "Documento adjunto con la traza."
  Call WORKFLOW (1,"ZSF","",GUSER) From AWRK
  If dim(GCORREO)   > 0 Then : Kill GCORREO   : Endif
  If dim(GFICHERO)  > 0 Then : Kill GFICHERO  : Endif
  If dim(GTEXTO1)   > 0 Then : Kill GTEXTO1   : Endif
  If dim(GTEXTO2)   > 0 Then : Kill GTEXTO2   : Endif
  If dim(GTEXTO3)   > 0 Then : Kill GTEXTO3   : Endif
  If dim(GASUNTO)   > 0 Then : Kill GASUNTO   : Endif
End

##############################################################
$MUEVE_FILE
  ORDSYS = "move " + filpath(WSGARECIBIDOS,"", "","","","")+'\' + WFICINP1 + ".xml " + filpath(WSGATRATADOS,"", "","","","")+'\' + WFICINP1 + ".xml "
  Call SYSTEME2(adxmac(-1),ORDSYS,"",NFICH2,FICH2) From ORDSYS
Return

##############################################################
$MUEVE_FILE_ERR
  ORDSYS = "move " + filpath(WSGARECIBIDOS,"", "","","","")+'\' + WFICINP1 + ".xml " + filpath(WSGAERROR,"", "","","","")+'\' + WFICINP1 + ".xml "
  Call SYSTEME2(adxmac(-1),ORDSYS,"",NFICH2,FICH2) From ORDSYS
Return

##############################################################
$RESU_WESTADOS
  WNESTADO=0
  For N=1 To 5
    If WESTADOS(N)=WSTATUS
      WNESTADO=N
      Break
    Endif
  Next
Return

##############################################################
$OBTENER_DISPONIBLE
  #Copiado de proceso CNSSFCSTD pantalla CONSSFC1 - Consulta stocl por planta
  Local Integer WSTA
  WSTA=0
  WDISPO=0
  #valor WSTA
  Read [F:ZITG]ITG1=[F:ZITM]TCLCOD;'PHISP'
  If fstat
    Read [ZITG]ITG1=[F:ZITM]TCLCOD;""
    If fstat Raz [F:ZITG] Endif
  Endif
  If [F:ZITG]GLOAAAFLG = 2   WSTA += 1  Endif
  If [F:ZITG]GLOQQQFLG = 2   WSTA += 2  Endif
  If [F:ZITG]GLORRRFLG = 2   WSTA += 4  Endif
  Call STODISPO("",'PHISP',WLNEITEMCODE,"*","*",1,WSTA,"","",WDISPO) From STKLIB
Return

##############################################################
$CREA_ENTRADA_VARIA

  Openo filpath(WSGATMP,WFICINP1+_ENTVARIA,''),0  Using [ZECO2]
  Iomode adxifs ""                                Using [ZECO2]
  Iomode adxirs chr$(13) + chr$(10)               Using [ZECO2]
  Iomode adxium 0                                 Using [ZECO2]

  Local Integer WLONG
  WLCOMILLAS='"'
  WLCOMA=';'
  #E
  WLONG=1
  RESULT='E'
  RESULT = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
  Wrseq RESULT+WLCOMA; Using [ZECO2]
  #VCRTYP
  WLONG=2
  RESULT='19'
  RESULT = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
  Wrseq RESULT+WLCOMA; Using [ZECO2]
  #VCRNUM
  WLONG=1
  RESULT=''
  RESULT = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
  RESULT=vireblc(RESULT,1)
  Wrseq RESULT+WLCOMA; Using [ZECO2]
  #STOFCY
  WLONG=5
  Filter [ZFCY] Where ZFCYMECALUX=WSITE
  Read [ZFCY] First
  RESULT=[F:ZFCY]FCY
  RESULT = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
  Wrseq RESULT+WLCOMA; Using [ZECO2]
 #IPTDAT
  WLONG=8
  RESULT= format$("YYYYMMDD",date$)
  RESULT = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
  Wrseq RESULT+WLCOMA; Using [ZECO2]
 #VCRDES
  WLONG=250
  RESULT=WCOMMENT
  RESULT = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
  RESULT=vireblc(RESULT,1)
  Wrseq RESULT+WLCOMA; Using [ZECO2]
 #TRSCOD
  WLONG=1
  RESULT=''
  RESULT = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
  RESULT=vireblc(RESULT,1)
  Wrseq RESULT Using [ZECO2]

  #L
  WLONG=1
  RESULT='L'
  RESULT = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
  RESULT=vireblc(RESULT,1)
  Wrseq RESULT+WLCOMA; Using [ZECO2]
  #VCRLIN
  WLONG=6
  RESULT=num$(WNLIN)
  RESULT = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
  RESULT=vireblc(RESULT,1)
  Wrseq RESULT+WLCOMA; Using [ZECO2]
  #ITMREF
  WLONG=250
  RESULT=WITEMCODE
  RESULT = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
  RESULT=vireblc(RESULT,1)
  Wrseq RESULT+WLCOMA; Using [ZECO2]
  #PCU
  WLONG=50
  RESULT=WUOMCODE
  RESULT = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
  RESULT=vireblc(RESULT,1)
  Wrseq RESULT+WLCOMA; Using [ZECO2]
  #QTYPCU
  WLONG=250
  RESULT=num$(WQUANTITYVAR)
  RESULT = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
  RESULT=vireblc(RESULT,1)
  Wrseq RESULT+WLCOMA; Using [ZECO2]
  #STU
  WLONG=50
  RESULT=WUOMCODE
  RESULT = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
  RESULT=vireblc(RESULT,1)
  Wrseq RESULT+WLCOMA; Using [ZECO2]
  #QTYSTU
  WLONG=250
  RESULT=num$(WQUANTITYVAR)
  RESULT = toupper(ctrans(left$(RESULT+space$(WLONG),WLONG)))
  RESULT=vireblc(RESULT,1)
  Wrseq RESULT Using [ZECO2]

  mkstat = 0 : fstat = 0 : GERRTRACE = 0
  Call IMPORTSIL ("ZSMR",filpath(WSGATMP,WFICINP1,"",""))From GIMPOBJ
Return

##############################################################
Funprog GET_PROPXML(XMLSTRING,VARNAME,I)
Value Clbfile XMLSTRING
Value Char VARNAME
Variable Integer I

Local Integer J
  I=instr(I,XMLSTRING,'<'+VARNAME+'>')
  If I
    I=instr(I+len(VARNAME),XMLSTRING,'>')
    If I
        J=instr(I+1,XMLSTRING,'<')
        If J
          CRETORNO=seg$(XMLSTRING,I+1,J-1)
          I+=len("\"+VARNAME)
          End CRETORNO
        Endif
    Endif
  Endif
End ""



################################################ NUEVO CÁLCULO DE STOCK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# JC 17112021.INI

##############################################################
# Cantidad Física Lote:
# Cantidad de stock total existente en Sage X3 (independientemente de cantidad asignada) en el estado de stock para la entrega (en general siempre será A) de un LOTE concreto
Funprog GET_QFL(PITMREF,PLOT,PSTA,PSTOFCY)
Value Char PITMREF,PLOT,PSTA,PSTOFCY

Local Decimal LRES

  If !clalev([F:ZSTO]) Then : Local File STOCK [F:ZSTO] : Endif

  If PSTA <> "" Then
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOT = PLOT and LOC = "SGA" and STOFCY = PSTOFCY and STA = PSTA
  Else
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOT = PLOT and LOC = "SGA" and STOFCY = PSTOFCY and STA = 'A'
  Endif
  For [F:ZSTO]
    LRES += [F:ZSTO]QTYSTU
  Next
  Filter [F:ZSTO]

  Close Local File [ZSTO]

End LRES

##############################################################
# Cantidad Física Total:
# Cantidad de stock total existente en Sage X3 (independientemente de cantidad asignada) en el estado de stock para la entrega (en general siempre será A) de todos los totes existentes en stock
Funprog GET_QFT(PITMREF,PSTA,PSTOFCY)
Value Char PITMREF,PSTA,PSTOFCY

Local Decimal LRES

  If !clalev([F:ZSTO]) Then : Local File STOCK [F:ZSTO] : Endif

  If PSTA <> "" Then
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOC = "SGA" and STOFCY = PSTOFCY and STA = PSTA
  Else
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOC = "SGA" and STOFCY = PSTOFCY and STA = 'A'
  Endif
  For [F:ZSTO]
    LRES += [F:ZSTO]QTYSTU
  Next

  Close Local File [ZSTO]

End LRES

##############################################################
# Cantidad Disponible Lote
# Cantidad de stock disponible (físico menos asignado detalle) en el estado de stock para entrega de un LOTE concreto
Funprog GET_QDL(PITMREF,PLOT,PSTA,PSTOFCY)
Value Char PITMREF,PLOT,PSTA,PSTOFCY

Local Decimal LRES,LSTKFIS,LSTKASD

  If !clalev([F:ZSTO]) Then : Local File STOCK  [F:ZSTO] : Endif
  If !clalev([F:ZSTA]) Then : Local File STOALL [F:ZSTA] : Endif

  # cantidad stock físico de un lote concreto
  LSTKFIS = func GET_QFL(PITMREF,PLOT,PSTA,PSTOFCY)
  If PSTA <> "" Then
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOT = PLOT and LOC = "SGA" and STOFCY = PSTOFCY and STA = PSTA
  Else
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOT = PLOT and LOC = "SGA" and STOFCY = PSTOFCY and STA = 'A'
  Endif
  Read [F:ZSTO] First
  If !fstat Then
    Filter [F:ZSTA] Where STOCOU = [F:ZSTO]STOCOU and ALLTYP = 2
    For [F:ZSTA]
      # cantidad stock asignado en detalle de un lote concreo
      LSTKASD += [F:ZSTA]QTYSTU
    Next
    Filter [F:ZSTA]
  Endif
  Filter [F:ZSTO]

  Close Local File [ZSTO],[ZSTA]

  LRES = LSTKFIS - LSTKASD

End LRES

##############################################################
# Cantidad Disponible Total:
# Cantidad de stock disponible (físico menos asignado detalle o global) en el estado de stock para entrega, de todos los lotes existentes en stock
Funprog GET_QDT(PITMREF,PSTA,PSTOFCY)
Value Char PITMREF,PSTA,PSTOFCY

Local Decimal LRES,LSTKFIS,LSTKASD,LSTKASG

  If !clalev([F:ZSTO]) Then : Local File STOCK  [F:ZSTO] : Endif
  If !clalev([F:ZSTA]) Then : Local File STOALL [F:ZSTA] : Endif

  If PSTA <> "" Then
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOC = "SGA" and STOFCY = PSTOFCY and STA = PSTA
  Else
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOC = "SGA" and STOFCY = PSTOFCY and STA = 'A'
  Endif
  For [F:ZSTO]
    # cantidad stock físico de todos los lotes en la ubicación SGA
    LSTKFIS += [F:ZSTO]QTYSTU
    Filter [F:ZSTA] Where STOCOU = [F:ZSTO]STOCOU and ALLTYP = 2
    For [F:ZSTA]
      # cantidad stock asignado en detalle de todos los lotes en la ubicación SGA
      LSTKASD += [F:ZSTA]QTYSTU
    Next
    Filter [F:ZSTA]
  Next
  Filter [F:ZSTO]

  Filter [F:ZSTA] Where STOCOU = 0 and ITMREF = PITMREF and ALLTYP = 1
  For [F:ZSTA]
    # cantidad stock asignado global
    LSTKASG += [F:ZSTA]QTYSTU
  Next
  Filter [F:ZSTA]

  Close Local File [ZSTO],[ZSTA]

  LRES = LSTKFIS - (LSTKASD + LSTKASG)

End LRES

##############################################################
# Cantidad Asignada Lote:
# Cantidad de stock asignada en detalle en el estado de stock para entrega de un LOTE concreto
Funprog GET_QAL(PITMREF,PLOT,PSTA,PSTOFCY)
Value Char PITMREF,PLOT,PSTA,PSTOFCY

Local Decimal LRES

  If !clalev([F:ZSTO]) Then : Local File STOCK  [F:ZSTO] : Endif
  If !clalev([F:ZSTA]) Then : Local File STOALL [F:ZSTA] : Endif

  If PSTA <> "" Then
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOT = PLOT and LOC = "SGA" and STOFCY = PSTOFCY and STA = PSTA
  Else
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOT = PLOT and LOC = "SGA" and STOFCY = PSTOFCY and STA = 'A'
  Endif
  Read [F:ZSTO] First
  If !fstat Then
    Filter [F:ZSTA] Where STOCOU = [F:ZSTO]STOCOU and ALLTYP = 2
    For [F:ZSTA]
      LRES += [F:ZSTA]QTYSTU
    Next
    Filter [F:ZSTA]
  Endif
  Filter [F:ZSTO]

  Close Local File [ZSTO],[ZSTA]

End LRES

##############################################################
# Cantidad Asignada Total:
# Cantidad de stock asignada en detalle + asignada global, en el estado de stock para entrega (incluir todas las asignaciones: en pedidos, vales,…)
Funprog GET_QAT(PITMREF,PSTA,PSTOFCY)
Value Char PITMREF,PSTA,PSTOFCY

Local Decimal LRES

  If !clalev([F:ZSTA]) Then : Local File STOALL [F:ZSTA] : Endif
  If !clalev([F:ZSTO]) Then : Local File STOCK  [F:ZSTO] : Endif

  # cantidad stock asignado en detallade para el artículo+estado+ubicación
  If PSTA <> "" Then
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOC = "SGA" and PSTOFCY = PSTOFCY and STA = PSTA
  Else
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOC = "SGA" and PSTOFCY = PSTOFCY and STA = 'A'
  Endif
  For [F:ZSTO]
    Filter [F:ZSTA] Where STOCOU = [F:ZSTO]STOCOU and ALLTYP = 2
    For [F:ZSTA]
      LRES += [F:ZSTA]QTYSTU
    Next
    Filter [F:ZSTA]
  Next
  Filter [F:ZSTO]
  # cantidad stock asignado global para el artículo
  Filter [F:ZSTA] Where ITMREF = PITMREF and STOCOU = 0 and ALLTYP = 1
  For [ZSTA]
    LRES += [F:ZSTA]QTYSTUACT
  Next
  Filter [F:ZSTA]

  Close Local File [ZSTO],[ZSTA]

End LRES

##############################################################
# Cantidad Asignada lote a pedidos de venta:
# Cantidad de stock asignada en detalle en el estado de stock para entrega de un LOTE concreto, que está asignada a pedidos de venta. Solo
# las asignaciones a pedidos de venta pendientes pueden ser canceladas
Funprog GET_QALPED(PITMREF,PLOT,PSTA,PSTOFCY)
Value Char PITMREF,PLOT,PSTA,PSTOFCY

Local Decimal LRES

  If !clalev([F:ZSTO]) Then : Local File STOCK  [F:ZSTO] : Endif
  If !clalev([F:ZSTA]) Then : Local File STOALL [F:ZSTA] : Endif

  If PSTA <> "" Then
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOT = PLOT and LOC = "SGA" and STOFCY = PSTOFCY and STA = PSTA
  Else
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOT = PLOT and LOC = "SGA" and STOFCY = PSTOFCY and STA = 'A'
  Endif
  Read [F:ZSTO] First
  If !fstat Then
    Filter [F:ZSTA] Where STOCOU = [F:ZSTO]STOCOU and VCRTYP = 2 and ALLTYP = 2
    For [F:ZSTA]
      LRES += [F:ZSTA]QTYSTU
    Next
    Filter [F:ZSTA]
  Endif
  Filter [F:ZSTO]

  Close Local File [ZSTO],[ZSTA]

End LRES

##############################################################
# Cantidad Asignada detallada a pedidos de venta:
# Cantidad de stock asignada en detalle en el estado de stock para entrega de todos los lotes, que está asignada a pedidos de venta. Solo
# las asignaciones a pedidos de venta pendientes pueden ser canceladas
Funprog GET_QADPED(PITMREF,PSTA,PSTOFCY)
Value Char PITMREF,PSTA,PSTOFCY

Local Decimal LRES

  If !clalev([F:ZSTO]) Then : Local File STOCK  [F:ZSTO] : Endif
  If !clalev([F:ZSTA]) Then : Local File STOALL [F:ZSTA] : Endif

  If PSTA <> "" Then
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOC = "SGA" and STOFCY = PSTOFCY and STA = PSTA
  Else
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOC = "SGA" and STOFCY = PSTOFCY and STA = 'A'
  Endif
  For [F:ZSTO]
    Filter [F:ZSTA] Where STOCOU = [F:ZSTO]STOCOU and VCRTYP = 2 and ALLTYP = 2
    For [F:ZSTA]
      LRES += [F:ZSTA]QTYSTU
    Next
    Filter [F:ZSTA]
  Next
  Filter [F:ZSTO]

  Close Local File [ZSTO],[ZSTA]

End LRES

##############################################################
# Cantidad Asignada global pedidos de venta:
# Cantidad de stock asignada global en el estado de stock para entrega, que está asignada a pedidos de venta. Solo las asignaciones a pedidos de venta pendientes pueden ser canceladas
Funprog GET_QAGPED(PITMREF)
Value Char PITMREF

Local Decimal LRES

  If !clalev([F:ZSTA]) Then : Local File STOALL [F:ZSTA] : Endif

  # en este filtro no se incluye el campo STA porque en la tabla STOALL siempre está en blanco
  Filter [F:ZSTA] Where STOCOU = 0 and ITMREF = PITMREF and VCRTYP = 2 and ALLTYP = 1
  For [F:ZSTA]
    LRES += [F:ZSTA]QTYSTUACT
  Next
  Filter [F:ZSTA]

  Close Local File [ZSTA]

End LRES

##############################################################
# Cantidad de la línea de detalle de stock a entregar del lote concreto a entregar
Funprog GET_QSOF(PNOMFICH,PPRHNUM,PPRELIN,PITMREF,PLOT)
Value Char    PNOMFICH,PPRHNUM,PITMREF,PLOT
Value Integer PPRELIN

#If GUSER="ADEV" Then Infbox "entra get_qsof" : Endif

  If !clalev([F:ZSOF]) Then : Local File ZEXPORTSOF [F:ZSOF] : Endif
  If PLOT <> 'NOTIENELOTE' Then
    Filter [F:ZSOF] Where NOMFICH = PNOMFICH and PRHNUM = PPRHNUM and PRELIN = PPRELIN and ITMREF = PITMREF and LOT = PLOT
  Else
    Filter [F:ZSOF] Where NOMFICH = PNOMFICH and PRHNUM = PPRHNUM and PRELIN = PPRELIN and ITMREF = PITMREF
  Endif
  For [ZSOF]
    LRES += [F:ZSOF]QTY
  Next
  Filter [F:ZSOF]
  Close Local File [ZSOF]

End LRES

##############################################################
# Cantidad Física Necesaria:
# Cantidad de stock físico que falta en Sage X3 para cubrir la necesidad
Funprog GET_QFN(PNOMFICH,PPRHNUM,PPRELIN,PITMREF,PSTOFCY)
Value Char    PNOMFICH,PPRHNUM,PITMREF,PSTOFCY
Value Integer PPRELIN

Local Decimal LRES

  # lres = cantidad de stock físico en x3 - cantidad de la línea de detalle en SOF
  LRES = abs(func GET_QFT(PITMREF,'',PSTOFCY) - func GET_QSOF(PNOMFICH,PPRHNUM,PPRELIN,PITMREF,''))

End LRES

##############################################################
# Cantidad a Asignar Necesaria del Lote:
# Cantidad de stock que falta por asignar (detalladamente por lote) para cubrir necesidad
Funprog GET_QAN(PNOMFICH,PPRHNUM,PPRELIN,PITMREF,PLOT,PSTA,PSTOFCY)
Value Char    PNOMFICH,PPRHNUM,PITMREF,PLOT,PSTA,PSTOFCY
Value Integer PPRELIN

Local Decimal LRES

  # lres = cantidad de la línea de detalle de stock en SOF - cantidad ya asignada en detalle en la línea del VP
  LRES = abs(func GET_QSOF(PNOMFICH,PPRHNUM,PPRELIN,PITMREF,PLOT) - func GET_QAVD(PNOMFICH,PPRHNUM,PPRELIN,PITMREF,PLOT,PSTA,PSTOFCY))

End LRES

##############################################################
# Cantidad Asignada Vale detalle:
# Cantidad asignada en detalle a línea del vale de preparación con el lote a registrar la salida (antes ejecución proceso integración)
Funprog GET_QAVD(PNOMFICH,PPRHNUM,PPRELIN,PITMREF,PLOT,PSTA,PSTOFCY)
Value Char    PNOMFICH,PPRHNUM,PITMREF,PLOT,PSTA,PSTOFCY
Value Integer PPRELIN

Local Decimal LRES

  If !clalev([F:ZSTO]) Then : Local File STOCK  [F:ZSTO] : Endif
  If !clalev([F:ZSTA]) Then : Local File STOALL [F:ZSTA] : Endif

  # cantidad asignada en detalle en un línea de VP
  If PSTA <> '' Then
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOT = PLOT and LOC = "SGA" and STOFCY = PSTOFCY and STA = PSTA
  Else
    Filter [F:ZSTO] Where ITMREF = PITMREF and LOT = PLOT and LOC = "SGA" and STOFCY = PSTOFCY and STA = 'A'
  Endif
  Read [F:ZSTO] First
  If !fstat Then
    Filter [F:ZSTA] Where STOCOU = [F:ZSTO]STOCOU and VCRTYP = 3 and ALLTYP = 2 and VCRNUM = PPRHNUM and VCRLIN = PPRELIN
    For [F:ZSTA]
      LRES += [F:ZSTA]QTYSTU
    Next
    Filter [F:ZSTA]
  Endif
  Filter [F:ZSTO]

  Close Local File [ZSTO],[ZSTA]

End LRES

##############################################################
# Cantidad Asignada Vale global:
# Cantidad asignada de tipo global a la línea del vale de preparación (antes ejecución proceso integración)
Funprog GET_QAVG(PNOMFICH,PPRHNUM,PPRELIN,PITMREF)
Value Char    PNOMFICH,PPRHNUM,PITMREF
Value Integer PPRELIN

Local Decimal LRES

  If !clalev([F:ZSTA]) Then : Local File STOALL [F:ZSTA] : Endif

  # cantidad asignada global en un línea de VP
  Filter [F:ZSTA] Where STOCOU = 0 and VCRTYP = 3 and ALLTYP = 1 and VCRNUM = PPRHNUM and VCRLIN = PPRELIN
  For [F:ZSTA]
    LRES += [F:ZSTA]QTYSTUACT
  Next
  Filter [F:ZSTA]

  Close Local File [ZSTA]

End LRES

##############################################################
Funprog COMPRUEBA_STOCK(PNOMFICH,PMESSAGE)
Value     Char    PNOMFICH
Variable  Char    PMESSAGE

Local Integer LRES    # 0=stock inferior ; 1=stock igual o superior
Local Integer LRET
Local Decimal LQSOF,LQAVD,LQAVG,LQTY,LUPDQTY
Local Integer LUPDFLG

  If !clalev([F:ZSTA]) Then : Local File STOALL  [F:ZSTA] : Endif
  If !clalev([F:ZES1]) Then : Local File ZVESOF1 [F:ZES1] : Endif
  If !clalev([F:ZES6]) Then : Local File ZVESOF6 [F:ZES6] : Endif

# 06.315.150.ini
#  Filter [F:ZES1] Where NOMFICH = PNOMFICH and INDICADOR = 'L'
  Filter [F:ZES1] Where NOMFICH = PNOMFICH and INDICADOR = 'L' and ZGENSDHFLG = 2
# 06.315.150.fin
  # proceso por cada línea del vale de preparación
  For [ZES1]
    Raz LUPDQTY
    Filter [F:ZSTA] Where VCRNUM = [F:ZES1]PRHNUM and VCRLIN = [F:ZES1]PRELIN
    Read [F:ZSTA] First
    # si la línea del vale tiene asignación DETALLADA en SAGE X3
    If [F:ZSTA]ALLTYP = 2 Then
      # por cada línea de detalle de stock de la línea del vale de preparación del fichero SOF:
      Filter [F:ZES6] Where NOMFICH = [F:ZES1]NOMFICH and PRHNUM = [F:ZES1]PRHNUM and PRELIN = [F:ZES1]PRELIN and ITMREF = [F:ZES1]ITMREF
      Raz LQSOF,LQAVD,LUPDFLG
      For [ZES6]
        # comprobar cantidad y lote fichero SOF vs cantidad y lote asignado en SAGE X3
        LQSOF = func GET_QSOF([F:ZES6]NOMFICH,[F:ZES6]PRHNUM,[F:ZES6]PRELIN,[F:ZES6]ITMREF,[F:ZES6]LOT)
        LQAVD = func GET_QAVD([F:ZES6]NOMFICH,[F:ZES6]PRHNUM,[F:ZES6]PRELIN,[F:ZES6]ITMREF,[F:ZES6]LOT,'A',[F:ZES6]STOFCY)
        If LQSOF = LQAVD Then
          # Se entrega exactamente la misma cantidad del lote que la asignación previa detallada en el vale. No es necesario realizar ningún ajuste,
          # la cantidad ya asignada en línea de vale coindice con lo entregado
          LUPDQTY +=  [F:ZES6]QTY
        Elsif LQSOF < LQAVD Then
          LUPDFLG =   1
          LUPDQTY +=  [F:ZES6]QTY
        Elsif LQSOF > LQAVD Then
          LUPDFLG = 1
          LUPDQTY +=  [F:ZES6]QTY
          # Se entrega más cantidad del lote que la asignación previa detallada en el vale
          # Ejecutar [Verificar stock] y autocorrección si se necesita
          Call VERIFICAR_STOCK([F:ZES6]NOMFICH,[F:ZES6]PRHNUM,[F:ZES6]PRELIN,[F:ZES6]ITMREF,[F:ZES6]LOT,'A','DET',0)
        Endif
      Next
      Filter [F:ZES6]

# 06.315.591.ini
      Local Decimal LQTYVP
      If LUPDFLG = 0 Then
        If !clalev([F:ZPRE2]) Then : Local File STOPRED [F:ZPRE2] : Endif
        Read [F:ZPRE2]PRE0 = [F:ZES1]PRHNUM;[F:ZES1]PRELIN
        If !fstat Then
          LQTYVP = [F:ZPRE2]QTYSTU
        Endif
        Close Local File [ZPRE2]
      Endif

      If LUPDFLG = 1 or LQTYVP > LUPDQTY Then
# 06.315.591.fin

        # JC.14122021.INI
        # Se cancela la cantidad asignada global
        Call DELALL(3,[F:ZES1]PRHNUM,[F:ZES1]PRELIN,0,[F:ZES1]ITMREF,0,[F:ZES1]QTY,[F:ZES1]QTY,LRET) From STKALL
# 06.314.358.ini
        If LRET = 1 Then
          Call ECR_TRACE("Error al desasignar la línea"-num$([F:ZES1]PRELIN)-"del VP"-[F:ZES1]PRHNUM,1) From GESECRAN
          GERRSTOCK = 1
        Endif
# 06.314.358.fin

        # Se asigna la cantidad detallada en la línea del vale por el lote indicado
        Filter [F:ZES6] Where NOMFICH = [F:ZES1]NOMFICH and PRHNUM = [F:ZES1]PRHNUM and PRELIN = [F:ZES1]PRELIN and ITMREF = [F:ZES1]ITMREF
        For [ZES6]
          Local Integer LSTOCOU
          If !clalev([F:STO9]) Then : Local File STOCK [F:STO9] : Endif
# 06.314.358.ini
#          Filter [F:STO9] Where ITMREF = [F:ZES6]ITMREF and LOT = [F:ZES6]LOT and STOFCY = [F:ZES6]STOFCY
          Filter [F:STO9] Where ITMREF = [F:ZES6]ITMREF and LOT = [F:ZES6]LOT and STOFCY = [F:ZES6]STOFCY and STA = 'A' and LOC = "SGA"
# 06.314.358.fin
          Read [F:STO9] First
          If !fstat Then
            LSTOCOU = [F:STO9]STOCOU
          Endif
          Filter [F:STO9]
          Close Local File [STO9]

          Call CREALL(2,[F:ZES6]STOFCY,[F:ZES6]ITMREF,LSTOCOU,[0/0/0],[F:ZES6]QTY,[F:ZES6]QTY,3,[F:ZES6]PRHNUM,[F:ZES6]PRELIN,0,
&                     '',date$,'','','','','','',0,0,'SGA','SGA','','',1,'',LRET) From STKALL
# 06.314.358.ini
          If LRET = 1 Then
            Call ECR_TRACE("Error al asignar la línea"-num$([F:ZES6]PRELIN)-"del VP"-[F:ZES6]PRHNUM,1) From GESECRAN
            GERRSTOCK = 1
          Endif
# 06.314.358.fin
        Next
        Filter [F:ZES6]
        # JC.14122021.FIN

        Call ACTUALIZA_STOPRED([F:ZES1]PRHNUM,[F:ZES1]PRELIN,LUPDQTY)

      Endif
    # si la línea del vale tiene asignación GLOBAL en SAGE X3
    Elsif [F:ZSTA]ALLTYP = 1 Then
      # por cada línea de detalle de stock de la línea del vale de preparación del fichero SOF:
      Raz LQSOF,LQAVG
      # 1. comprobar cantidad fichero SOF vs cantidad disponible en SAGE X3 y cantidad global asignada al Vale
      LQSOF = [F:ZES1]QTY
      LQAVG = func GET_QAVG([F:ZES1]NOMFICH,[F:ZES1]PRHNUM,[F:ZES1]PRELIN,[F:ZES1]ITMREF)
      # Entrega de la misma cantidad o menor a la asignada global en la línea del vale
      If LQSOF <= LQAVG Then
        Filter [F:ZES6] Where NOMFICH = [F:ZES1]NOMFICH and PRHNUM = [F:ZES1]PRHNUM and PRELIN = [F:ZES1]PRELIN and ITMREF = [F:ZES1]ITMREF
        For [ZES6]
          # Existe suficiente stock disponible del lote para registrar la asignación al vale
          If func GET_QDL([F:ZES6]ITMREF,[F:ZES6]LOT,'A','PHISP') >= LQSOF Then
            LUPDQTY +=  [F:ZES6]QTY
          Elsif func GET_QDL([F:ZES6]ITMREF,[F:ZES6]LOT,'A','PHISP') < LQSOF Then
            # Ejecutar [Verificar stock] y autocorrección si se necesita
            Call VERIFICAR_STOCK([F:ZES6]NOMFICH,[F:ZES6]PRHNUM,[F:ZES6]PRELIN,[F:ZES6]ITMREF,[F:ZES6]LOT,'A','GLO',[F:ZES1]QTY)
            LUPDFLG = 1
            LUPDQTY +=  [F:ZES6]QTY
          Endif
        Next
        Filter [F:ZES6]

        # JC.14122021.INI
        # Se cancela la cantidad asignada global
        Call DELALL(3,[F:ZES1]PRHNUM,[F:ZES1]PRELIN,0,[F:ZES1]ITMREF,0,[F:ZES1]QTY,[F:ZES1]QTY,LRET) From STKALL
# 06.314.358.ini
        If LRET = 1 Then
          Call ECR_TRACE("Error al desasignar la línea"-num$([F:ZES1]PRELIN)-"del VP"-[F:ZES1]PRHNUM,1) From GESECRAN
          GERRSTOCK = 1
        Endif
# 06.314.358.fin

        # Se asigna la cantidad detallada en la línea del vale por el lote indicado
        Filter [F:ZES6] Where NOMFICH = [F:ZES1]NOMFICH and PRHNUM = [F:ZES1]PRHNUM and PRELIN = [F:ZES1]PRELIN and ITMREF = [F:ZES1]ITMREF
        For [ZES6]
          Local Integer LSTOCOU
          If !clalev([F:STO9]) Then : Local File STOCK [F:STO9] : Endif
# 06.314.358.ini
#          Filter [F:STO9] Where ITMREF = [F:ZES6]ITMREF and LOT = [F:ZES6]LOT and STOFCY = [F:ZES6]STOFCY
          Filter [F:STO9] Where ITMREF = [F:ZES6]ITMREF and LOT = [F:ZES6]LOT and STOFCY = [F:ZES6]STOFCY and STA = 'A' and LOC = "SGA"
# 06.314.358.fin
          Read [F:STO9] First
          If !fstat Then
            LSTOCOU = [F:STO9]STOCOU
          Endif
          Filter [F:STO9]
          Close Local File [STO9]

          Call CREALL(2,[F:ZES6]STOFCY,[F:ZES6]ITMREF,LSTOCOU,[0/0/0],[F:ZES6]QTY,[F:ZES6]QTY,3,[F:ZES6]PRHNUM,[F:ZES6]PRELIN,0,
&                     '',date$,'','','','','','',0,0,'SGA','SGA','','',1,'',LRET) From STKALL
# 06.314.358.ini
          If LRET = 1 Then
            Call ECR_TRACE("Error al asignar la línea"-num$([F:ZES6]PRELIN)-"del VP"-[F:ZES6]PRHNUM,1) From GESECRAN
            GERRSTOCK = 1
          Endif
# 06.314.358.fin
        Next
        Filter [F:ZES6]
        # JC.14122021.FIN

        Call ACTUALIZA_STOPRED([F:ZES1]PRHNUM,[F:ZES1]PRELIN,LUPDQTY)

      # Entrega de mayor cantidad asignada global
      Elsif LQSOF > LQAVG Then
        Filter [F:ZES6] Where NOMFICH = [F:ZES1]NOMFICH and PRHNUM = [F:ZES1]PRHNUM and PRELIN = [F:ZES1]PRELIN and ITMREF = [F:ZES1]ITMREF
        For [ZES6]
          LUPDQTY +=  [F:ZES6]QTY
          # Ejecutar [Verificar stock] y autocorrección si se necesita
          Call VERIFICAR_STOCK([F:ZES6]NOMFICH,[F:ZES6]PRHNUM,[F:ZES6]PRELIN,[F:ZES6]ITMREF,[F:ZES6]LOT,'A','GLO',[F:ZES1]QTY)
        Next
        Filter [F:ZES6]

        # Se cancela la cantidad asignada global
        # JC.14122021.INI
        Call DELALL(3,[F:ZES1]PRHNUM,[F:ZES1]PRELIN,0,[F:ZES1]ITMREF,0,[F:ZES1]QTY,[F:ZES1]QTY,LRET) From STKALL
# 06.314.358.ini
        If LRET = 1 Then
          Call ECR_TRACE("Error al desasignar la línea"-num$([F:ZES1]PRELIN)-"del VP"-[F:ZES1]PRHNUM,1) From GESECRAN
          GERRSTOCK = 1
        Endif
# 06.314.358.fin

        # Se asigna la cantidad detallada en la línea del vale por el lote indicado
        Filter [F:ZES6] Where NOMFICH = [F:ZES1]NOMFICH and PRHNUM = [F:ZES1]PRHNUM and PRELIN = [F:ZES1]PRELIN and ITMREF = [F:ZES1]ITMREF
        For [ZES6]
          Local Integer LSTOCOU
          If !clalev([F:STO9]) Then : Local File STOCK [F:STO9] : Endif
# 06.314.358.ini
#          Filter [F:STO9] Where ITMREF = [F:ZES6]ITMREF and LOT = [F:ZES6]LOT and STOFCY = [F:ZES6]STOFCY
          Filter [F:STO9] Where ITMREF = [F:ZES6]ITMREF and LOT = [F:ZES6]LOT and STOFCY = [F:ZES6]STOFCY and STA = 'A' and LOC = "SGA"
# 06.314.358.fin
          Read [F:STO9] First
          If !fstat Then
            LSTOCOU = [F:STO9]STOCOU
          Endif
          Filter [F:STO9]
          Close Local File [STO9]

          Call CREALL(2,[F:ZES6]STOFCY,[F:ZES6]ITMREF,LSTOCOU,[0/0/0],[F:ZES6]QTY,[F:ZES6]QTY,3,[F:ZES6]PRHNUM,[F:ZES6]PRELIN,0,
&                     '',date$,'','','','','','',0,0,'SGA','SGA','','',1,'',LRET) From STKALL
# 06.314.358.ini
          If LRET = 1 Then
            Call ECR_TRACE("Error al asignar la línea"-num$([F:ZES6]PRELIN)-"del VP"-[F:ZES6]PRHNUM,1) From GESECRAN
            GERRSTOCK = 1
          Endif
# 06.314.358.fin
        Next
        Filter [F:ZES6]
        # JC.14122021.FIN

        Call ACTUALIZA_STOPRED([F:ZES1]PRHNUM,[F:ZES1]PRELIN,LUPDQTY)
      Endif
    Endif
    Filter [F:ZSTA]
  Next
  Filter [F:ZES1]
  Close Local File  [ZSTA],[ZES1],[ZES6]

End LRES

##############################################################
Funprog VERIFICAR_STOCK(PNOMFICH,PPRHNUM,PPRELIN,PITMREF,PLOT,PSTA,PTIPOAS,PQSOF)
Value Char    PNOMFICH,PPRHNUM,PITMREF,PLOT,PSTA,PTIPOAS
Value Integer PPRELIN
Value Decimal PQSOF

Local Integer LRES
Local Decimal LQAN,LQALPED,LQAGPED
Local Decimal LQFT,LQAT,LQSOF,LQAVG,LQAVD,LQDL
Local Decimal LQTYACANCELARGLOBAL,LQTYPENDIENTEACANCELAR,LQTYERRORAREGULARIZAR,LQTYPENDIENTEDESPUESDECANCELAR
Local Decimal LQADPED

  # 1. Calcular cantidad que necesitamos (nos falta) del lote indicado por SOF para ajustar la asignación al vale en modo detallado (QAN)
  LQAN = func GET_QAN(PNOMFICH,PPRHNUM,PPRELIN,PITMREF,PLOT,PSTA,'PHISP')
  # Si línea vale asignada detalladamente, necesitamos la diferencia respecto lo ya asignado al vale, teniendo en cuenta la cantidad disponible que podemos asignar
  If PTIPOAS = "DET" Then
    # QAN = QSOF – QAVD – QDL
    LQSOF = func GET_QSOF(PNOMFICH,PPRHNUM,PPRELIN,PITMREF,PLOT)
    LQAVD = func GET_QAVD(PNOMFICH,PPRHNUM,PPRELIN,PITMREF,PLOT,PSTA,'PHISP')
    LQDL  = func GET_QDL(PITMREF,PLOT,PSTA,'PHISP')
    LQAN  = LQSOF - LQAVD - LQDL
  # Si línea vale asignada globalmente necesitamos la cantidad total entregada, teniendo en cuenta la cantidad disponible que podemos asignar
  Else
    # QAN = QSOF – QDL
    LQSOF = func GET_QSOF(PNOMFICH,PPRHNUM,PPRELIN,PITMREF,PLOT)
    LQDL  = func GET_QDL(PITMREF,PLOT,PSTA,'PHISP')
    LQAN  = LQSOF - LQDL
  Endif

  # 2. Calcular cantidad asignada detallada del lote entregado a pedidos de venta. Solo las asignaciones a pedidos de venta pendientes pueden ser canceladas: QAL Ped.
  LQALPED = func GET_QALPED(PITMREF,PLOT,PSTA,'PHISP')

  # 3. Calcular cantidad asignada global a pedidos de venta (asignación global sin detalle de lote). Solo las asignaciones a pedidos de venta pendientes pueden ser canceladas: QAG Ped.
  LQAGPED = func GET_QAGPED(PITMREF)

  # 4. Ejecutar acciones de autocorrección de stock según el estado asignaciones de stock
  If LQAN < 0 Then
  # Si QAN < 0 -> QAN = 0
  # Disponemos de suficiente stock para realizar la asignación en la línea del vale. No es necesario modificar nada
    LQAN = 0
  Elsif LQAN <= LQALPED Then
    # Si QAN <= QAL Ped
    # Si la cantidad necesaria pendiente de asignar detalladamente a la línea del vale de preparación es inferior o igual a la cantidad asignada del lote,
    # con la cancelación de las asignaciones existentes en pedidos podremos registrar la asignación en el vale entregado por el SGA
    # Ejecutar [Cancelación stock asignado Detallado] por la cantidad QAN
    Call CANCELACION_STOCK_ASIGNADO_DETALLADO(PITMREF,LQAN,PLOT,PSTA,LQTYPENDIENTEDESPUESDECANCELAR)
  Elsif LQAN > LQALPED
    # Si QAN > QAL Ped
    # Si la cantidad necesaria pendiente de asignar detalladamente a la línea del vale de preparación es superior a la cantidad asignada del lote en pedidos de venta,
    # con la cancelación de las asignaciones existentes en pedidos no tendremos suficiente stock disponible para registrar la asignación en el vale entregado por el SGA
    # Puesto que la entrega se ha realizado de este lote, y debe ser este lote el que tenemos que entregar, se tendrá que realizar un ajuste del stock físico para
    # completar la cantidad necesaria
    # Ejecutar [Cancelación stock asignado Detallado] por la cantidad QAL Ped
    Call CANCELACION_STOCK_ASIGNADO_DETALLADO(PITMREF,LQALPED,PLOT,PSTA,LQTYPENDIENTEDESPUESDECANCELAR)
    # Ejecutar [Entrada stock físico lote] por la diferencia para cubrir la necesidad (QAN - QAL Ped)
    Local Decimal LQTYATRATAR : LQTYATRATAR = LQAN - LQALPED
    Call ENTRADA_STOCK_FISICO_LOTE(PITMREF,LQTYATRATAR,PLOT,PSTA)
  Endif

  # 5. Comprobar cantidad física total existente del artículo, QFT, en comparación con la cantidad total asignada en detalle o global, QAT,
  # teniendo en cuenta la asignación existente en el vale (cantidad asignada previamente al proceso de importación) y la nueva asignación que se registrará en el vale.
  # Esta comprobación busca verificar si la asignación de más cantidad, aunque tengamos stock disponible de un lote dejaría una asignación total (detallada + global) superior
  # a la cantidad física. Es decir, dejaría stock incoherente y tiene que ser corregido
  LQFT  = func GET_QFT(PITMREF,PSTA,'PHISP')
  LQAT  = func GET_QAT(PITMREF,PSTA,'PHISP')
  LQSOF = func GET_QSOF(PNOMFICH,PPRHNUM,PPRELIN,PITMREF,PLOT)
  LQAVG = func GET_QAVG(PNOMFICH,PPRHNUM,PPRELIN,PITMREF)
  LQAVD = func GET_QAVD(PNOMFICH,PPRHNUM,PPRELIN,PITMREF,PLOT,PSTA,'PHISP')
  Local Decimal LQTYCOMP
  If PTIPOAS = 'DET' Then
    LQTYCOMP = LQAT + LQSOF - (LQAVG + LQAVD)
  Else
    LQTYCOMP = LQAT + PQSOF - (LQAVG + LQAVD)
  Endif
  If LQFT < LQTYCOMP Then
    LQTYACANCELARGLOBAL = LQTYCOMP - LQFT
    Call CANCELACION_STOCK_ASIGNADO_GLOBAL(PITMREF,LQTYACANCELARGLOBAL,PSTA,LQTYPENDIENTEDESPUESDECANCELAR)
    # Si no podemos cancelar asignaciones globales por el total que necesitamos cancelar. En este caso debemos cancelar asignaciones de stock detallado
    LQTYPENDIENTEACANCELAR = LQTYPENDIENTEDESPUESDECANCELAR
    LQADPED = func GET_QADPED(PITMREF,PSTA,'PHISP')
    If LQTYPENDIENTEACANCELAR > 0 Then
      # Si cantidad pendiente a cancelar <= QAD Ped
      # Ejecutar [Cancelación stock asignado detalle] de cualquier lote, por cantidad pendiente cancelar
      Call CANCELACION_STOCK_ASIGNADO_DETALLADO(PITMREF,LQTYPENDIENTEACANCELAR,PLOT,PSTA,LQTYPENDIENTEDESPUESDECANCELAR)
      # Si cantidad pendiente a cancelar > QAD Ped
      # Ejecutar [Cancelación stock asignado detalle] de cualquier lote, por la cantidad QAD Ped. es decir, cancelar todas las asignaciones detalladas a pedidos.
      # Si no podemos cancelar toda la cantidad pendiente a cancelar, pero las asignaciones se encuentran en fases que no podemos cancelar
      # automáticamente (en vales pendientes o en entregas pendientes de validar)
      # En esta situación, la única solución es registrar una entrada varia para que, aunque el stock no será correcto, sea coherente con las cantidades asignadas.
      # Ejecutar [Entrada stock físico lote] por la cantidad error a regularizar y lote en blanco o lote “ERR”
      LQTYERRORAREGULARIZAR = LQTYPENDIENTEDESPUESDECANCELAR
      If LQTYERRORAREGULARIZAR > 0 Then
        Call ENTRADA_STOCK_FISICO_LOTE(PITMREF,LQTYERRORAREGULARIZAR,PLOT,PSTA)
      Endif
    Endif
  Endif

End

##############################################################
Subprog ENTRADA_STOCK_FISICO_LOTE(PITMREF,PQTY,PLOT,PSTA)
Value Char    PITMREF,PLOT,PSTA
Value Decimal PQTY

  If !clalev([F:ZSTO1]) Then : Local File STOCK     [F:ZSTO1] : Endif
  If !clalev([F:ZITV1]) Then : Local File ITMMVT    [F:ZITV1] : Endif
  If !clalev([F:ZITM1]) Then : Local File ITMMASTER [F:ZITM1] : Endif

  Filter  [F:ZSTO1] Where ITMREF = PITMREF and STA = PSTA and LOT = PLOT
  Read    [F:ZSTO1] First
  Read    [F:ZITV1]ITV0 = PITMREF;"PHISP"
  Read    [F:ZITM1]ITM0 = PITMREF

  Call ECR_TRACE("Entrada stock físico"-num$(PQTY)-"unidades del lote:"-PLOT,0) From GESECRAN
  # entrada varia
  Local Char LFECHA(250),LHORA(250)
  LFECHA = vireblc(num$(date$),4) : LFECHA = mid$(LFECHA,1,2)+mid$(LFECHA,4,2)+mid$(LFECHA,7,4)
  LHORA  = vireblc(num$(time$),4) : LHORA  = mid$(LHORA,1,2)+mid$(LHORA,4,2)
  Local Char LFILE_W_EV(250) : LFILE_W_EV = filpath("ZSGA\SGA\IMPORTX3","","") + "\EV_" + LFECHA + LHORA + ".txt"
  adxifs = ";"
  adxirs = chr$(13)+chr$(10)
  Openo LFILE_W_EV Using [YIMP_WEV]
  Wrseq "E" + ";" + num$(19) + ";" + "" + ";" + "PHISP" + ";" + date$ + ";" + "Ajustes SGA entrega" + ";" + "REG" + ";" + "010"                           Using [YIMP_WEV]
  Wrseq "L" + ";" + num$(1000) + ";" + PITMREF + ";" + [F:ZITM1]SAU + ";" + num$(PQTY) + ";" + [F:ZITM1]SAU + ";" + num$(PQTY) + ";" + num$([F:ZITV1]AVC) Using [YIMP_WEV]
  Wrseq "S" + ";" + [F:ZITM1]SAU + ";" + num$(PQTY) + ";" + "" + ";" + PLOT + ";" + "SGA" + ";" + "A" + ";" + "Ajustes SGA entrega"                       Using [YIMP_WEV]
  Openo Using [YIMP_WEV]
  mkstat = 0 : fstat = 0 : GERRTRACE = 0
  Call IMPORTSIL("ZSMR2",LFILE_W_EV) From GIMPOBJ

  If filinfo(LFILE_W_EV, 7) > 0 Then
    System "ae_rm " + LFILE_W_EV                                                        # borra el fichero .txt
  Endif

  Filter  [F:ZSTO1]
  Close Local File [ZSTO1],[ZITV1],[ZITM1]

End

##############################################################
Subprog CANCELACION_STOCK_ASIGNADO_DETALLADO(PITMREF,PQTY,PLOT,PSTA,PQTYREST)
Value     Char    PITMREF,PLOT,PSTA
Value     Decimal PQTY
Variable  Decimal PQTYREST

Local     Decimal LQTYDESASIG

  PQTYREST = PQTY

  If !clalev([F:STO1]) Then : Local File STOCK        [F:STO1] : Endif
  If !clalev([F:STO2]) Then : Local File STOCK        [F:STO2] : Endif
  If !clalev([F:ZVAL]) Then : Local File ZVSTVALLSOH  [F:ZVAL] : Endif
  If !clalev([F:ZVA1]) Then : Local File ZVSTVALLSOH  [F:ZVA1] : Endif
  If !clalev([F:ZALK]) Then : Local File APLLCK       [F:ZALK] : Endif
  If !clalev([F:ZAL1]) Then : Local File APLLCK       [F:ZAL1] : Endif

  Filter [F:STO1] Where STOFCY = "PHISP" and ITMREF = PITMREF and LOT = PLOT and STA = PSTA and LOC = "SGA"
  Read [F:STO1] First
  If !fstat Then
    # Búsqueda de las líneas de pedido con asignaciones detalladas al artículo, lote y estado indicado, ordenadas por fecha de pedido descendente
    Filter [F:ZVAL] Where STOCOU = [F:STO1]STOCOU and VCRTYP = 2 and ALLTYP = 2 Order By ORDDAT Desc
    For [F:ZVAL]
      Filter [F:ZALK] Where LCKSYM = "SOH"+[F:ZVAL]SOHNUM   # desasigna sólo si el pedido no está abierto (bloqueado por alguien)
      Read [F:ZALK] First
      If fstat <> 0 Then
        # Ejecutar proceso cancelación de asignaciones detalladas de las líneas de pedido anteriores hasta haber desasignado una cantidad igual o superior a la cantidad indicada
        Call ECR_TRACE("Cancelación stock asignado detallado. Pedido:"-[F:ZVAL]SOHNUM-",línea:"-num$([F:ZVAL]SOPLIN)-",lote:"-PLOT,0) From GESECRAN
        Call UPD_DEASIG_SOH([F:ZVAL]SOHNUM,[F:ZVAL]SOPLIN,[F:ZVAL]SOQSEQ,[F:ZVAL]STOFCY,[F:ZVAL]SHIDAT) From ZAULIB01
        LQTYDESASIG = [F:ZVAL]QTYSTUACT
        PQTYREST    -= LQTYDESASIG
        If PQTYREST <= 0 Then
          Break
        Endif
      Endif
      Filter [F:ZALK]
    Next
    Filter [F:ZVAL]
  Endif
  Filter [F:STO1]

  If PQTYREST > 0 Then
    Filter [F:STO2] Where STOFCY = "PHISP" and ITMREF = PITMREF and STA = PSTA and LOC = "SGA" and LOT <> PLOT
    For [F:STO2]
      # Búsqueda de las líneas de pedido con asignaciones detalladas al artículo, lote y estado indicado, ordenadas por fecha de pedido descendente
      Filter [F:ZVA1] Where STOCOU = [F:STO2]STOCOU and VCRTYP = 2 and ALLTYP = 2 Order By ORDDAT Desc
      For [F:ZVA1]
        Filter [F:ZAL1] Where LCKSYM = "SOH"+[F:ZVA1]SOHNUM   # desasigna sólo si el pedido no está abierto (bloqueado por alguien)
        Read [F:ZAL1] First
        If fstat <> 0 Then
          # Ejecutar proceso cancelación de asignaciones detalladas de las líneas de pedido anteriores hasta haber desasignado una cantidad igual o superior a la cantidad indicada
          Call ECR_TRACE("Cancelación stock asignado detallado. Pedido:"-[F:ZVA1]SOHNUM-",línea:"-num$([F:ZVA1]SOPLIN)-",lote:"-[F:STO2]LOT,0) From GESECRAN
          Call UPD_DEASIG_SOH([F:ZVA1]SOHNUM,[F:ZVA1]SOPLIN,[F:ZVA1]SOQSEQ,[F:ZVA1]STOFCY,[F:ZVA1]SHIDAT) From ZAULIB01
          LQTYDESASIG = [F:ZVA1]QTYSTUACT
          PQTYREST    -= LQTYDESASIG
          If PQTYREST <= 0 Then
            Break
          Endif
        Endif
        Filter [F:ZAL1]
      Next
      Filter [F:ZVA1]
    Next
    Filter [F:STO2]
  Endif

  Close Local File [STO1],[STO2],[ZVAL],[ZVA1],[ZALK],[ZAL1]

End

##############################################################
Subprog CANCELACION_STOCK_ASIGNADO_GLOBAL(PITMREF,PQTY,PSTA,PQTYREST)
Value     Char    PITMREF,PSTA
Value     Decimal PQTY
Variable  Decimal PQTYREST

Local     Decimal LQTYDESASIG

  PQTYREST = PQTY

  If !clalev([F:ZVA2]) Then : Local File ZVSTVALLSOH2 [F:ZVA2] : Endif
  If !clalev([F:ZALK]) Then : Local File APLLCK       [F:ZALK] : Endif

  # Búsqueda de las líneas de pedido con asignaciones globales del artículo (y estado indicado), ordenadas por fecha de pedido descendente
  Filter [F:ZVA2] Where ITMREF = PITMREF and STOCOU = 0 and VCRTYP = 2 Order By ORDDAT Desc; SOHNUM Desc; QTYSTUACT Asc
  For [F:ZVA2]
    Filter [F:ZALK] Where LCKSYM = "SOH"+[F:ZVA2]SOHNUM   # desasigna sólo si el pedido no está abierto (bloqueado por alguien)
    Read [F:ZALK] First
    If fstat <> 0 Then
      # Ejecutar proceso cancelación de asignaciones globales de las líneas de pedido anteriores hasta haber desasignado una cantidad igual o superior a la cantidad indicada
      Call ECR_TRACE("Cancelación stock asignado global. Pedido:"-[F:ZVA2]SOHNUM-",línea:"-num$([F:ZVA2]SOPLIN),0) From GESECRAN
      Call UPD_DEASIG_SOH([F:ZVA2]SOHNUM,[F:ZVA2]SOPLIN,[F:ZVA2]SOQSEQ,[F:ZVA2]STOFCY,[F:ZVA2]SHIDAT) From ZAULIB01
      LQTYDESASIG += [F:ZVA2]QTYSTUACT
      PQTYREST    -= LQTYDESASIG
      If PQTYREST <= 0 Then
        Break
      Endif
    Endif
    Filter [F:ZALK]
  Next
  Filter [F:ZVA2]

  Close Local File [ZVA2],[ZALK]

End

###############################################################
#**
#* elimina del VP todas aquellas líneas que no llegan en el fichero SOF
#*
#* @param PNOMFICH  > nombre del fichero SOF
#*!
Subprog ELIMINA_LINEA_VP(PNOMFICH)
Value Char    PNOMFICH

Local Integer LRET
Local Char    LSOHORI(50),LORDDAT(15),LSOHNUM(50)
Local Integer LSOPLIN,LSOPSEQ,LSOPLIN,LSOPSEQ
Local File    ITMMASTER
Local Decimal LQTYPRE

  If !clalev([F:AXX1]) Then : Local File ZVESOF3    [F:AXX1] : Endif
  If !clalev([F:AXX2]) Then : Local File STOPRED    [F:AXX2] : Endif
  If !clalev([F:AXX3]) Then : Local File ZVESOF7    [F:AXX3] : Endif
  If !clalev([F:AXX4]) Then : Local File STOPRED    [F:AXX4] : Endif
  If !clalev([F:ZSOH]) Then : Local File SORDER     [F:ZSOH] : Endif
  If !clalev([F:ZSOQ]) Then : Local File SORDERQ    [F:ZSOQ] : Endif
  If !clalev([F:ZSOP]) Then : Local File SORDERP    [F:ZSOP] : Endif

# 1.- marcar las líneas del VP que aparecen en el fichero SOF
  For [AXX1]
    Read [F:AXX2]PRE0 = [F:AXX1]PRHNUM;[F:AXX1]PRELIN
    If !fstat Then
      [F:AXX2]ZSGASOFFLG = 2
      Trbegin [F:AXX2]
      Rewrite [F:AXX2]
      If !fstat Then
        Commit
      Else
        Rollback
      Endif
    Endif
  Next

# 2.- recorrer las líneas del VP para eliminar las que no aparecen el el fichero SOF
  For [AXX3]
    Filter [F:AXX4] Where PRHNUM = [F:AXX3]PRHNUM and ZSGASOFFLG <> 2
    Read [F:AXX4] First
    If !fstat Then
      If [F:AXX4]STOMGTCOD<>1                                           # 06.308.480.new
# 3.- desasignar la línea del VP
        Call DELALL(3,[F:AXX4]PRHNUM,[F:AXX4]PRELIN,0,[F:AXX4]ITMREF,0,[F:AXX4]ALLQTY,[F:AXX4]ALLQTY,LRET) From STKALL
        If LRET<>0 Goto ENDNEXTDEL Endif
# 4.- borrar la línea del VP
        LSOHNUM = [F:AXX4]ORINUM
        LSOPLIN = [F:AXX4]ORILIN
        LSOPSEQ = [F:AXX4]ORISEQ
        LQTYPRE = [F:AXX4]QTYSTU
        Trbegin [F:AXX4]
        Delete [F:AXX4]
        If !fstat Then
          Commit
        Else
          Rollback
        Endif
# 5.- reasignar la línea del pedido
        Read [F:ZSOH]SOH0 = LSOHNUM
        Read [F:ZSOQ]SOQ0 = LSOHNUM;LSOPLIN;LSOPSEQ
        Read [F:ZSOP]SOP0 = LSOHNUM;LSOPLIN;LSOPSEQ
        Trbegin [F:ZSOQ]
        [F:ZSOQ]OPRQTY    -= LQTYPRE
        [F:ZSOQ]OPRQTYSTU -= LQTYPRE
        Rewrite [F:ZSOQ]
        If !fstat Then
          Commit
        Else
          Rollback
        Endif
      Endif                                                             # 06.308.480.new
    Endif
    $ENDNEXTDEL
  Next

  Close Local File [AXX1],[AXX2],[AXX3],[AXX4],[ZSOH],[ZSOQ],[ZSOP]

End

###############################################################
#**
#* actualiza los campos en la tabla STOPRED
#*
#* @param PPRHNUM  > número de VP
#* @param PPRELIN  > línea del VP
#* @param PQTY     > cantidad a actualizar
#*!
Subprog ACTUALIZA_STOPRED(PPRHNUM,PPRELIN,PQTY)
Value Char    PPRHNUM
Value Integer PPRELIN
Value Decimal PQTY

  If !clalev([F:ZPRE])  Then : Local File STOPRED [F:ZPRE]  : Endif

  Read [F:ZPRE]PRE0 = PPRHNUM;PPRELIN
  If !fstat Then
    Trbegin [F:ZPRE]
    [F:ZPRE]ALLTYP    = 2
    [F:ZPRE]UPDDAT    = date$
    [F:ZPRE]UPDDATTIM = datetime$
    [F:ZPRE]ZEXPORT   = 2
    [F:ZPRE]QTYSTU    = PQTY
    [F:ZPRE]ALLQTY    = PQTY
    [F:ZPRE]OALQTYSTU = PQTY
    Rewrite [F:ZPRE]
    If !fstat Then
      Commit
      GSTERROR = 0
    Else
      Rollback
      Call ECR_TRACE("Error en VP:"-PPRHNUM-"/ Línea:"-num$(PPRELIN),1) From GESECRAN
      GSTERROR = 1
    Endif
  Else
    Call ECR_TRACE("No existe el VP:"-PPRHNUM-"/ Línea:"-num$(PPRELIN),1) From GESECRAN
    GSTERROR  = 1
    GERRSTOCK = 1                                                                             # 06.315.150.new
  Endif

  Close Local File [ZPRE]

End

###############################################################
#**
#* genera la entrega a partir del vale
#*
#* @param PNOMFICH  > nombre del fichero SOF
#*!
Subprog GENERA_ENTREGA(PNOMFICH,PWSGATMP,PWFICINP1,PWSGARECIBIDOS,PWSGATRATADOS,PWSGAERROR)
Value     Char    PNOMFICH,PWSGATMP,PWFICINP1,PWSGARECIBIDOS,PWSGATRATADOS,PWSGAERROR

Local Integer LFICH2, STAT
Local Char    LFILETXT(250), LFILEXML(250), LDIRIMPORTTMP(250), LDIRIMPORTRECIBIDOS(250), LDIRIMPORTTRATADOS(250), LDIRIMPORTERROR(250)
Local Char    LSHIDAT(15),LDLVDAT(15),LMESSAGE(250)

  LDIRIMPORTTMP       = filpath(PWSGATMP,"","")
  LDIRIMPORTRECIBIDOS = filpath(PWSGARECIBIDOS,"","")
  LDIRIMPORTTRATADOS  = filpath(PWSGATRATADOS,"","")
  LDIRIMPORTERROR     = filpath(PWSGAERROR,"","")

  LFILETXT = LDIRIMPORTTMP + "\" + PWFICINP1 + ".txt"
  LFILEXML = LDIRIMPORTRECIBIDOS + "\" + PWFICINP1 + ".xml"

  # borramos el fichero si existe...
  If filinfo(LFILETXT, 7) > 0 Then
    System "ae_rm " + LFILETXT
  Endif

  adxifs = ";"
  adxirs = chr$(13)+chr$(10)
  Openo LFILETXT Using [ZIMP]

  Call ECR_TRACE("Generación del fichero "+PWFICINP1+".txt",0) From GESECRAN
  Call ECR_TRACE("---------------------------------------",0) From GESECRAN

  If !clalev([F:ZESOF]) Then : Local File ZEXPORTSOF  [F:ZESOF] : Endif
  If !clalev([F:ZESOX]) Then : Local File ZEXPORTSOF  [F:ZESOX] : Endif
  If !clalev([F:ZESO2]) Then : Local File ZVESOF2     [F:ZESO2] : Endif
  If !clalev([F:ZESO5]) Then : Local File ZVESOF5     [F:ZESO5] : Endif
  If !clalev([F:ZPRE])  Then : Local File STOPRED     [F:ZPRE]  : Endif
# 06.298.127.ini
  If !clalev([F:ZSOH1]) Then : Local File SORDER      [F:ZSOH1] : Endif
  If !clalev([F:ZPRE1]) Then : Local File STOPRED     [F:ZPRE1] : Endif
# 06.298.127.fin
# 06.300.273.ini
  If !clalev([F:ZES11]) Then : Local File ZVESOF11    [F:ZES11] : Endif
# 06.300.273.fin

  Filter [F:ZESO2] Where NOMFICH = PNOMFICH and ZGENSDHFLG = 2 Order By SDHNUM
  For [F:ZESO2]
    # añade al fichero la cabecera del vale desde la tabla específica
    Filter [F:ZESOF] Where NOMFICH = [F:ZESO2]NOMFICH and SDHNUM = [F:ZESO2]SDHNUM and INDICADOR = "H"
    Read [F:ZESOF] First
    If !fstat Then
# 06.298.127.ini
      Local Char LTRANSP(250)
      Local Char LCONFCOOP(250)                                                         # 06.309.060.new
      Local Char LCONDPAGO(250)                                                         # 06.310.719.new
      Local Char LINCOTERM(250),LCTYINCOT(250)                                          # 06.319.759.new
      # obtención del trasnportista del pedido que genera el vale de preparación
      Filter [F:ZPRE1] Where PRHNUM = [F:ZESOF]PRHNUM and ORINUM <> ''
      Read   [F:ZPRE1] First
        If !fstat Then
          Read [F:ZSOH1]SOH0 = [F:ZPRE1]ORINUM
          If !fstat Then
            LTRANSP       = [F:ZSOH1]BPTNUM
            LCONFCOOP     = [F:ZSOH1]ZNUMCOOPE                                              # 06.309.060.new
            LCONDPAGO     = [F:ZSOH1]PTE                                                    # 06.310.719.new
            LINCOTERM     = [F:ZSOH1]EECICT                                                 # 06.319.759.new
            LCTYINCOT     = [F:ZSOH1]ICTCTY                                                 # 06.319.759.new
          Endif
        Endif
      Filter [F:ZPRE1]
# 06.298.127.fin

      LSHIDAT = left$(num$([F:ZESOF]SHIDAT),2)+mid$(num$([F:ZESOF]SHIDAT),4,2)+mid$(num$([F:ZESOF]SHIDAT),7,4)
      LDLVDAT = left$(num$([F:ZESOF]DLVDAT),2)+mid$(num$([F:ZESOF]DLVDAT),4,2)+mid$(num$([F:ZESOF]DLVDAT),7,4)
      Wrseq [F:ZESOF]INDICADOR  + ";" + [F:ZESOF]SALFCY   + ";" + [F:ZESOF]STOFCY       + ";" +
&           [F:ZESOF]SDHNUM     + ";" + [F:ZESOF]SDHTYP   + ";" + [F:ZESOF]BPCORD       + ";" +
&           [F:ZESOF]BPAADD     + ";" + [F:ZESOF]CUR      + ";" + LSHIDAT               + ";" +
&           LDLVDAT + ";" + [F:ZESOF]PACNBR   + ";" + [F:ZESOF]ZTIPOPEDSGA  + ";" + LTRANSP + ";" + LCONFCOOP + ";" + LCONDPAGO + ";" + LINCOTERM + ";" + LCTYINCOT Using [ZIMP] # 06.319.759
#&           LDLVDAT             + ";" + [F:ZESOF]PACNBR   + ";" + [F:ZESOF]ZTIPOPEDSGA  + ";" + LTRANSP + ";" + LCONFCOOP + ";" + LCONDPAGO Using [ZIMP]      # 06.310.719.new
#&           LDLVDAT             + ";" + [F:ZESOF]PACNBR   + ";" + [F:ZESOF]ZTIPOPEDSGA  + ";" + LTRANSP + ";" + LCONFCOOP Using [ZIMP]      # 06.309.060.new
#&           LDLVDAT             + ";" + [F:ZESOF]PACNBR   + ";" + [F:ZESOF]ZTIPOPEDSGA  + ";" + LTRANSP Using [ZIMP]      # 06.298.127.new
#&           LDLVDAT             + ";" + [F:ZESOF]PACNBR   + ";" + [F:ZESOF]ZTIPOPEDSGA  Using [ZIMP]
    Endif
    Filter [F:ZESOF]
# 06.300.273.ini
#    # añade al fichero las líneas del vale desde la tabla específica
#    Filter [F:ZESO5] Where NOMFICH = [F:ZESOF]NOMFICH and INDICADOR = "L" and SDHNUM = [F:ZESOF]SDHNUM Order By PRHNUM;PRELIN
#    For [F:ZESO5]
#      Call ECR_TRACE("  VP:"-[F:ZESO5]PRHNUM-"/ Línea:"-num$([F:ZESO5]PRELIN)-"/ Artículo:"-[F:ZESO5]ITMREF-"/ Cantidad:"-num$([F:ZESO5]QTY),0) From GESECRAN
#      Wrseq [F:ZESO5]INDICADOR  + ";" + [F:ZESO5]PRHNUM   + ";" + num$([F:ZESO5]PRELIN) + ";" +
#&           [F:ZESO5]ITMREF     + ";" + [F:ZESO5]ITMDES   + ";" + num$([F:ZESO5]QTY)    + ";" +
#&           [F:ZESO5]SAU        + ";" + [F:ZESO5]ZLOTPROV + ";" + [F:ZESO5]ZUSRSERV     Using [ZIMP]
##      STAT = func COMPRUEBA_STOCK([F:ZESO5]PRHNUM,[F:ZESO5]PRELIN,LMESSAGE)
##      If STAT = 0 Then
##        Call ECR_TRACE(LMESSAGE,1) From GESECRAN
##      Endif
#    Next
#    Filter [F:ZESO5]
    # añade al fichero las líneas del vale desde la tabla específica
    Filter [F:ZES11] Where NOMFICH = [F:ZESOF]NOMFICH and INDICADOR = "L" and SDHNUM = [F:ZESOF]SDHNUM Order By PRHNUM;PRELIN
    For [F:ZES11]
      Call ECR_TRACE("  VP:"-[F:ZES11]PRHNUM-"/ Línea:"-num$([F:ZES11]PRELIN)-"/ Artículo:"-[F:ZES11]ITMREF-"/ Cantidad:"-num$([F:ZES11]QTY),0) From GESECRAN
      Wrseq [F:ZES11]INDICADOR  + ";" + [F:ZES11]PRHNUM   + ";" + num$([F:ZES11]PRELIN) + ";" +
&           [F:ZES11]ITMREF     + ";" + [F:ZES11]ITMDES   + ";" + num$([F:ZES11]QTY)    + ";" +
&           [F:ZES11]SAU        + ";" + [F:ZES11]ZLOTPROV + ";" + [F:ZES11]ZUSRSERV     Using [ZIMP]
    Next
    Filter [F:ZES11]
# 06.300.273.fin
    # añade al fichero, desde la tabla de líneas de vale de preparación, aquellas líneas que contengan artículos que no gestionen stock (CERT001)
    Filter [F:ZESOX] Where NOMFICH = [F:ZESOF]NOMFICH and INDICADOR = "H" and SDHNUM = [F:ZESOF]SDHNUM Order By PRHNUM;PRELIN
    For [F:ZESOX]
      Filter [F:ZPRE] Where PRHNUM = [F:ZESOX]PRHNUM and STOMGTCOD = 1
      For [F:ZPRE]
        Call ECR_TRACE("  VP:"-[F:ZPRE]PRHNUM-"/ Línea:"-num$([F:ZPRE]PRELIN)-"/ Artículo:"-[F:ZPRE]ITMREF-"/ Cantidad:"-num$([F:ZPRE]QTYSTU),0) From GESECRAN
        Wrseq "L"                 + ";" + [F:ZPRE]PRHNUM    + ";" + num$([F:ZPRE]PRELIN) + ";" +
&             [F:ZPRE]ITMREF      + ";" + [F:ZPRE]ITMDES1   + ";" + num$([F:ZPRE]QTYSTU) + ";" +
&             [F:ZPRE]STU         + ";" + ""                + ";" + ""                   Using [ZIMP]
      Next
      Filter [F:ZPRE]
    Next
  Next

# 06.298.127.ini
#  Close Local File [ZESOF],[ZESOX],[ZESO2],[ZESO5],[ZPRE]
  Close Local File [ZESOF],[ZESOX],[ZESO2],[ZESO5],[ZPRE],[ZSOH1],[ZPRE1],[ZES11]
# 06.298.127.fin

  # cerramos el fichero
  Openo Using [ZIMP]

  mkstat = 0 : fstat = 0 : GERRTRACE = 0

  # lanzamos la importación
  Call ECR_TRACE("########################################################################",0) From GESECRAN
  Call ECR_TRACE("Lanza la importación",0) From GESECRAN
  mkstat = 0 : fstat = 0 : GERRTRACE = 0
  Call IMPORTSIL ("ZSDHSOF",LFILETXT)From GIMPOBJ
  Call ECR_TRACE("Datos importsil: fstat="+num$(fstat)-"-"-"GERRTRACE="+num$(GERRTRACE),0) From GESECRAN

  # gestiona un error en la importación
# 06.314.358.ini
#  If (fstat <> 0 and fstat <> 4) or GERRTRACE <> 0 Then                           # si se produce error de importación...
  If (fstat <> 0 and fstat <> 4) or GERRTRACE <> 0 or GERRSTOCK = 1 Then          # si se produce error de importación...
# 06.314.358.fin
    If filinfo(LFILETXT+".err", 7) > 0 Then
      Call MOVE(LFILETXT+".err",LDIRIMPORTERROR,STAT) From ORDSYS                 # mueve el fichero .err con errores en la importación
    Endif
    If filinfo(LFILEXML, 7) > 0 Then
      Call MOVE(LFILEXML,LDIRIMPORTERROR,STAT) From ORDSYS                        # mueve el fichero xml a la carpeta de procesados
    Endif
    Call  LANZA_WORKFLOW_ERRORES(PNOMFICH)
    Call ECR_TRACE("########################################################################",0) From GESECRAN
    Call ECR_TRACE("Error en la importación",1) From GESECRAN
  Else
    If filinfo(LFILEXML,7) > 0 Then
      Call MOVE(LFILEXML,LDIRIMPORTTRATADOS,STAT) From ORDSYS                         # mueve el fichero xml a la carpeta de procesados
    Endif
    Call ECR_TRACE("########################################################################",0) From GESECRAN
    Call ECR_TRACE("Importación correcta",0) From GESECRAN

  Endif

  If filinfo(LFILETXT, 7) > 0 Then
    System "ae_rm " + LFILETXT
  Endif

  Call ECR_TRACE("########################################################################",0) From GESECRAN

End

###############################################################
#**
#* desbloquea control de crédito en cliente
#*
#* @param PNOMFICH  > nombre del fichero SOF
#*!
Subprog UNLOCK_OSTCTL(PNOMFICH)
Value Char    PNOMFICH

  If !clalev([F:ZESO9]) Then : Local File ZVESOF9     [F:ZESO9] : Endif
  If !clalev([F:ZBPC])  Then : Local File BPCUSTOMER  [F:ZBPC]  : Endif

  Filter [F:ZESO9] Where NOMFICH = PNOMFICH and OSTCTL = 3
  For [ZESO9]
    Read [F:ZBPC]BPC0 = [F:ZESO9]BPCORD
    If !fstat Then
      [F:ZBPC]OSTCTL = 1
      Trbegin [F:ZBPC]
      Rewrite [F:ZBPC]
      If !fstat Then
        Commit
      Else
        Rollback
      Endif
    Endif
  Next
  Filter [F:ZESO9]
  Close Local File [ZESO9],[ZBPC]
End

###############################################################
#**
#* bloquea control de crédito en cliente
#*
#* @param PNOMFICH  > nombre del fichero SOF
#*!
Subprog LOCK_OSTCTL(PNOMFICH)
Value Char    PNOMFICH

  If !clalev([F:ZESO9]) Then : Local File ZVESOF9     [F:ZESO9] : Endif
  If !clalev([F:ZBPC])  Then : Local File BPCUSTOMER  [F:ZBPC]  : Endif

  Filter [F:ZESO9] Where NOMFICH = PNOMFICH and OSTCTL = 3
  For [ZESO9]
    Read [F:ZBPC]BPC0 = [F:ZESO9]BPCORD
    If !fstat Then
      [F:ZBPC]OSTCTL = 3
      Trbegin [F:ZBPC]
      Rewrite [F:ZBPC]
      If !fstat Then
        Commit
      Else
        Rollback
      Endif
    Endif
  Next
  Filter [F:ZESO9]
  Close Local File [ZESO9],[ZBPC]
End

###############################################################
# 06.304.506
#**
#* activa cliente
#*
#* @param PNOMFICH  > nombre del fichero SOF
#*!
Subprog UNLOCK_BPCSTA(PNOMFICH)
Value Char    PNOMFICH

  If !clalev([F:ZESO9]) Then : Local File ZVESOF9     [F:ZESO9] : Endif
  If !clalev([F:ZBPD0]) Then : Local File BPDLVCUST   [F:ZBPD0]  : Endif

  Filter [F:ZESO9] Where NOMFICH = PNOMFICH and BPCSTA <> 2
  For [ZESO9]
    Read [F:ZBPD0]BPD0 = [F:ZESO9]BPCORD;[F:ZESO9]BPAADD
    If !fstat Then
      [F:ZBPD0]ENAFLG = 2
      Trbegin [F:ZBPD0]
      Rewrite [F:ZBPD0]
      If !fstat Then
        Commit
      Else
        Rollback
      Endif
    Endif
  Next
  Filter [F:ZESO9]
  Close Local File [ZESO9],[ZBPD0]
End

###############################################################
# 06.304.506
#**
#* desactiva cliente
#*
#* @param PNOMFICH  > nombre del fichero SOF
#*!
Subprog LOCK_BPCSTA(PNOMFICH)
Value Char    PNOMFICH

  If !clalev([F:ZESO9]) Then : Local File ZVESOF9     [F:ZESO9] : Endif
  If !clalev([F:ZBPD0]) Then : Local File BPDLVCUST   [F:ZBPD0]  : Endif

  Filter [F:ZESO9] Where NOMFICH = PNOMFICH and BPCSTA <> 2
  For [ZESO9]
    Read [F:ZBPD0]BPD0 = [F:ZESO9]BPCORD;[F:ZESO9]BPAADD
    If !fstat Then
      [F:ZBPD0]ENAFLG  = [F:ZESO9]BPCSTA
      Trbegin [F:ZBPD0]
      Rewrite [F:ZBPD0]
      If !fstat Then
        Commit
      Else
        Rollback
      Endif
    Endif
  Next
  Filter [F:ZESO9]
  Close Local File [ZESO9],[ZBPD0]
End
